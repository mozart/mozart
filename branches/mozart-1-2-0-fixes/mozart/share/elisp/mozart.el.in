;;;
;;; Authors:
;;;   Leif Kornstaedt <kornstae@ps.uni-sb.de>
;;;   Michael Mehl <mehl@ps.uni-sb.de>
;;;   Ralf Scheidhauer <scheihr@ps.uni-sb.de>
;;;
;;; Contributor:
;;;   Benjamin Lorenz <lorenz@ps.uni-sb.de>
;;;   Denys Duchier <duchier@ps.uni-sb.de>
;;;
;;; Copyright:
;;;   Leif Kornstaedt, Michael Mehl, and Ralf Scheidhauer, 1993-1998
;;;   Denys Duchier, 1998
;;;
;;; Last change:
;;;   $Date$ by $Author$
;;;   $Revision$
;;;
;;; This file is part of Mozart, an implementation of Oz 3:
;;;   http://www.mozart-oz.org
;;;
;;; See the file "LICENSE" or
;;;   http://www.mozart-oz.org/LICENSE.html
;;; for information on usage and redistribution
;;; of this file, and for a DISCLAIMER OF ALL
;;; WARRANTIES.
;;;

;; Functions for running a Mozart sub-process
;;

(require 'oz)
(require 'comint)
(require 'compile)
(require 'oz-server)

(eval-and-compile
  (defvar oz-old-frame-title
    (cond (oz-gnu-emacs
	   (cdr (assoc 'name (frame-parameters (car (visible-frame-list))))))
	  (oz-lucid-emacs
	   frame-title-format))
    "Saved Emacs frame title."))

;;}}}
;;{{{ Customization

(eval-and-compile
  (eval '(defgroup mozart nil
	   "Running a Mozart sub-process."
	   :group 'oz
	   :prefix "oz-")))

(eval-and-compile
  (eval '(defcustom OZ-HOME "@prefix@"
	   "*Directory where Mozart is installed.
Used as fallback if the environment variable OZHOME is not set."
	   :type 'string
	   :group 'mozart)))
(put 'OZ-HOME 'variable-interactive
     "DMozart installation directory: ")

(eval-and-compile
  (eval '(defun oz-home ()
	   "Return the path of the Mozart installation directory."
	   (let ((ret (getenv "OZHOME")))
	     (if ret
		 ret
	       (message "OZHOME not set, using fallback: %s" OZ-HOME)
	       (setenv "OZHOME" OZ-HOME)
	       OZ-HOME)))))

(eval-and-compile
  (eval '(defcustom oz-change-title t
	   "*If non-nil, change the Emacs frame title while Mozart is running."
	   :type 'boolean
	   :group 'mozart)))
(put 'oz-change-title 'variable-interactive
     "XChange frame title while Mozart is running? (t or nil): ")

(eval-and-compile
  (eval '(defcustom oz-frame-title
	   (concat "Oz Programming Interface (" oz-old-frame-title ")")
	   "*String to be used as Emacs frame title while Mozart is running."
	   :type 'string
	   :group 'mozart)))
(put 'oz-frame-title 'variable-interactive
     "sFrame title to use while Mozart is running: ")

(eval-and-compile
  (eval '(defcustom oz-prepend-line t
	   "*If non-nil, prepend a \\line directive to all Oz queries."
	   :type 'boolean
	   :group 'mozart)))
(put 'oz-prepend-line 'variable-interactive
     "XPrepend a \\line directive to all Oz queries? (t or nil): ")

(eval-and-compile
  (eval '(defcustom oz-default-host "localhost"
	   "*Default name of host to use for creating socket connections."
	   :type 'string
	   :group 'mozart)))
(put 'oz-default-host 'variable-interactive
     "sDefault host name to use for socket connections: ")

(eval-and-compile
  (eval '(defcustom oz-build-dir
	   (concat (getenv "HOME") "/mozart")
	   "*Path to the Mozart build directory for testing locally."
	   :type 'string
	   :group 'mozart)))
(put 'oz-build-dir 'variable-interactive
     "sPath to the Mozart build directory: ")

(eval-and-compile
  (eval '(defcustom oz-emulator
	   (or (getenv "OZEMULATOR")
	       (concat oz-build-dir "/platform/emulator/emulator.exe"))
	   "*Path to the Mozart Emulator for gdb mode and for \\[oz-other]."
	   :type 'string
	   :group 'mozart)))
(put 'oz-emulator 'variable-interactive
     "fMozart Emulator binary: ")

(eval-and-compile
  (eval '(defcustom oz-functor-path
	   (or (getenv "OZ_LOAD")
	       (concat "prefix=x-oz\\://system/="
		       oz-build-dir "/share/lib/:"
		       "prefix=x-oz\\://system/="
		       oz-build-dir "/share/tools/:"
		       "prefix=x-oz\\://boot/="
		       oz-build-dir "/platform/emulator/:"
		       "cache=~/.oz/cache:cache=" (oz-home) "/cache"))
	   "*Search path for the Oz functors (used by \\[oz-other])."
	   :type 'string
	   :group 'mozart)))
(put 'oz-functor-path 'variable-interactive
     "sOz functor search path: ")

(eval-and-compile
  (eval '(defcustom oz-root-functor
	   "x-oz://system/OPI.ozf"
	   "*Name of the root functor to load on startup."
	   :type 'string
	   :group 'mozart)))
(put 'oz-root-functor 'variable-interactive
     "sName of the root functor to load on startup: ")

(eval-and-compile
  (eval '(defcustom oz-gdb-autostart t
	   "*If non-nil, start emulator immediately when in gdb mode.
If nil, you have the possibility to first set breakpoints and only
run the emulator when you issue the command `run' to gdb."
	   :type 'boolean
	   :group 'mozart)))
(put 'oz-gdb-autostart 'variable-interactive
     "XStart emulator immediately when in gdb mode? (t or nil): ")

(eval-and-compile
  (eval '(defcustom oz-other-buffer-size 35
	   "*Percentage of screen to use for Oz Compiler/Emulator/Temp window."
	   :type 'integer
	   :group 'mozart)))
(put 'oz-other-buffer-size 'variable-interactive
     "nPercentage of screen to use for Oz windows: ")

(eval-and-compile
  (eval '(defcustom oz-popup-on-error t
	   "*If non-nil, pop up Compiler resp. Emulator buffer upon error."
	   :type 'boolean
	   :group 'mozart)))
(put 'oz-popup-on-error 'variable-interactive
     "XPop up Oz buffers on error? (t or nil): ")

(eval-and-compile
  (eval '(defcustom oz-halt-timeout 30
	   "*Number of seconds to wait for shutdown in oz-halt."
	   :type 'integer
	   :group 'mozart)))
(put 'oz-halt-timeout 'variable-interactive
     "nNumber of seconds to wait for shutdown of the Mozart sub-process: ")

(eval-and-compile
  (eval '(defcustom oz-compile-command "ozc -c %s"
	   "Default shell command to do a compilation.
This may contain at most one occurrence of `%s', which is replaced by the
current buffer's file name."
	   :type 'string
	   :group 'mozart)))
(put 'oz-compile-command 'variable-interactive
     "sShell command to do an Oz compilation: ")

(eval-and-compile
  (eval '(defcustom oz-application-command "%s"
	   "Default shell command to do execute an Oz application.
This may contain at most one occurrence of `%s', which is replaced by the
current buffer's file name, minus the `.oz' or `.ozg' extension."
	   :type 'string
	   :group 'mozart)))
(put 'oz-application-command 'variable-interactive
     "sShell command to invoke an Oz application: ")

(eval-and-compile
  (eval '(defcustom oz-engine-program
	   (concat (oz-home) "/bin/ozengine")
	   "Default Oz engine to run the OPI"
	   :type 'string
	   :group 'mozart)))
(put 'oz-engine-program 'variable-interactive
     "sDefault Oz engine to run the OPI: ")

;;}}}
;;{{{ Oz Profiles

(eval-and-compile
  (eval '(defcustom oz-profiles nil
	   "*An alist of profiles for multiple Mozart versions"
	   :group 'mozart
	   :type '(alist :key-type symbol
			 :value-type
			 (alist
			  :key-type symbol
			  :options ((OZ-HOME                string)
				    (oz-change-title        boolean)
				    (oz-frame-title         string)
				    (oz-prepend-line        boolean)
				    (oz-default-host        string)
				    (oz-build-dir           string)
				    (oz-emulator            string)
				    (oz-functor-path        string)
				    (oz-root-functor        string)
				    (oz-gdb-autostart       boolean)
				    (oz-other-buffer-size   integer)
				    (oz-popup-on-error      boolean)
				    (oz-halt-timeout        integer)
				    (oz-compile-command     string)
				    (oz-application-command string)
				    (oz-engine-program      string)))))))

(defvar oz-profile-undo nil)

(defun oz-profile-undo ()
  "Undo the bindings established by the current profile."
  (interactive)
  (let ((l oz-profile-undo))
    (while l
      (eval (car l))
      (setq l (cdr l)))
    (setq oz-profile-undo nil)))

(defun oz-profile-save-var (var)
  (setq oz-profile-undo
	(cons `(set ',var ',(eval ,var)) oz-profile-undo)))

(defun oz-profile-save-envvar (var)
  (setq oz-profile-undo
	(cons `(setenv ',var ',(getenv var)) oz-profile-undo)))

(defun oz-set-profile (name)
  "Select a profile from the alist oz-profiles.
This makes it easy to run multiple Mozart versions in the same
Emacs session, or the same version with different parameters.
A profile is an alist which provides specific bindings for variables
(and possibly affecting also the environment variable OZHOME)."
  (interactive
   (list (completing-read
	  "Profile: "
	  (mapcar (function
		   (lambda (p) (list (format "%s" (car p)))))
		  oz-profiles)
	  nil t (format "%s" (caar oz-profiles)))))
  (if (equal name "") nil
    (oz-profile-undo)
    (oz-profile-save-envvar "OZHOME")
    (let* ((key (intern name))
	   (alist (cdr (assq key oz-profiles))))
      (while alist
	(oz-profile-save-var (caar alist))
	(set (caar alist) (cdar alist))
	(setq alist (cdr alist))))
    (setenv "OZHOME" OZ-HOME)))

;;}}}
;;{{{ Variables/Initialization

(defvar oz-emulator-buffer "*Oz Emulator*"
  "Name of the Oz Emulator buffer.")

(defvar oz-compiler-buffer "*Oz Compiler*"
  "Name of the Oz Compiler buffer.")

(defvar oz-compiler-buffers nil
  "List of buffers in which Oz Compilers have been started.")

(defvar oz-temp-buffer "*Oz Temp*"
  "Name of the Oz temporary buffer.")

(defvar oz-buffered-send-string nil
  "List of buffered calls to oz-send-string.
These are performed only when the Oz Compiler is known to be running.")

(defvar oz-emulator-hook nil
  "If non-nil, hook used for starting the Oz Emulator.
This is set when gdb is active.")

(defvar oz-emulator-filter-hook nil
  "If non-nil, hook used as second process filter for the Oz Emulator.
This is set when gdb is active.")

(defconst oz-error-string (char-to-string 17)
  "Regex to recognize error messages from Oz Compiler and Emulator.
Used for popping up the corresponding buffer.")

(defconst oz-remove-pattern
  (concat oz-error-string "\\|"
	  (char-to-string 18) "\\|" (char-to-string 19) "\\|"
	  ;; Irix outputs garbage when sending EOF:
	  "\\" (char-to-string 4) (char-to-string 8) (char-to-string 8) "\\|"
	  ;; Under Windows, lines may be terminated by CRLF:
	  (char-to-string 13) "\\|"
	  ;; This is a directive we inserted ourselves:
	  "\\\\line.*% fromemacs\n")
  "Regex specifying what to remove from Compiler and Emulator output.
All strings matching this regular expression are removed.")

(defconst oz-socket-pattern
  "'oz-socket \\(\"\\([^\"]*\\)\" \\)?\\([0-9]+\\) \\([0-9]+\\)'"
  "Regex for reading the information about the compiler socket.")

(defconst oz-show-temp-pattern
  "\'oz-show-temp \\([^ ]*\\)\'"
  "Regex for reading messages from the Oz compiler.")

(defconst oz-bar-pattern
  "\'oz-bar \\([^ ]*\\) \\([0-9]+\\) \\([0-9]+\\|~1\\) \\([^ ]*\\)\'"
  "Regex for reading messages from the Oz debugger or profiler.")

;;}}}
;;{{{ Setting the Frame Title

(defun oz-set-title (frame-title)
  "Set the title of the Emacs frame."
  (cond ((not oz-change-title) t)
	(oz-gnu-emacs
	 (mapcar (function (lambda (scr)
			     (modify-frame-parameters
			      scr
			      (list (cons 'name frame-title)))))
		 (visible-frame-list)))
	(oz-lucid-emacs
	 (setq frame-title-format frame-title))))

;;}}}
;;{{{ Locating Errors

(defvar oz-compiler-output-start nil
  "Position in the Oz Compiler buffer where the last run's output began.")
(make-variable-buffer-local 'oz-compiler-output-start)

(defconst oz-error-intro-pattern "\\(error\\|warning\\) \\*\\*\\*\\*\\*"
  "Regular expression for finding error messages.")

(defconst oz-error-pattern
  (concat "in "
	  "\\(file \"\\([^\"\n]+\\)\",? *\\)?"
	  "line \\([0-9]+\\)"
	  "\\(,? *column \\([0-9]+\\)\\)?")
  "Regular expression matching error coordinates.")

(defun oz-compilation-parse-errors (&optional limit-search find-at-least)
  "Parse the current buffer as Mozart error messages.
See variable `compilation-parse-errors-function' for the interface it uses."
  (setq compilation-error-list nil)
  (message "Parsing error messages...")
  ;; Don't reparse messages already seen at last parse.
  (goto-char (max (or oz-compiler-output-start (point-min))
		  (or compilation-parsing-end 0)))
  (let ((num-found 0))
    (while (re-search-forward
	    oz-error-pattern
	    (and (or (null find-at-least)
		     (>= num-found find-at-least)) limit-search) t)
      (let* ((file-string (oz-match-string 2))
	     (line (string-to-number (oz-match-string 3)))
	     (column-string (oz-match-string 5))
	     (column (and column-string (string-to-number column-string)))
	     (error-marker (save-excursion
			     (and (oz-goto-error-start)
				  (progn (beginning-of-line)
					 (point-marker)))))
	     (buffer (and file-string
			  (oz-find-buffer-or-file file-string nil)))
	     (error-data
	      (cond ((not error-marker) nil)
		    ((not file-string)
		     (list error-marker))
		    (buffer
		     (save-excursion
		       (set-buffer buffer)
		       (save-restriction
			 (widen)
			 (goto-line line)
			 (if (and column (> column 0))
			     (forward-char column))
			 (cons error-marker (point-marker)))))
		    (t
		     (let* ((file (oz-normalize-file-name file-string))
			    (filedata (list file default-directory))
			    (error-data (if column
					    (list filedata line column)
					  (list filedata line))))
		       (cons error-marker error-data))))))
	(if error-data
	    (setq num-found (1+ num-found)
		  compilation-error-list
		  (cons error-data compilation-error-list))))))
  (setq compilation-error-list (nreverse compilation-error-list))
  (setq compilation-parsing-end (point))
  (message "Parsing error messages...done"))

(defun oz-goto-error-start ()
  ;; if point is in the middle of an error message (in the compiler buffer),
  ;; then it is moved to the start of the message.
  (let ((errstart
	 (save-excursion
	   (beginning-of-line)
	   (if (looking-at "%\\*\\*")
	       (re-search-backward oz-error-intro-pattern nil t)))))
    (if errstart (goto-char errstart))))

;;}}}
;;{{{ Utilities

(defun oz-line-region (arg)
  ;; Return starting and ending positions of ARG lines surrounding point.
  ;; Positions are returned as a pair ( START . END ).
  (save-excursion
    (let (start end)
      (cond ((> arg 0)
	     (beginning-of-line)
	     (setq start (point))
	     (forward-line (1- arg))
	     (end-of-line)
	     (setq end (point)))
	    ((= arg 0)
	     (setq start (point))
	     (setq end (point)))
	    ((< arg 0)
	     (end-of-line)
	     (setq end (point))
	     (forward-line arg)
	     (setq start (point))))
      (cons start end))))

(defun oz-paragraph-region (arg)
  ;; Return starting and ending positions of ARG paragraphs surrounding point.
  ;; Positions are returned as a pair ( START . END ).
  (save-excursion
    (let (start end)
      (cond ((> arg 0)
	     (backward-paragraph 1)
	     (setq start (point))
	     (forward-paragraph arg)
	     (setq end (point)))
	    ((= arg 0)
	     (setq start (point))
	     (setq end (point)))
	    ((< arg 0)
	     (forward-paragraph (1- arg))
	     (setq start (point))
	     (backward-paragraph (1- arg))
	     (setq end (point))))
      (cons start end))))

(defun oz-get-region (start end)
  ;; Return the region from START to END from the current buffer as a string.
  ;; Leading and terminating whitespace is trimmed from the string and
  ;; a \\line directive is prepended to it.
  (save-excursion
    (goto-char start)
    (skip-chars-forward " \t\n")
    (if (/= (count-lines start (point)) 0)
	(progn
	  (beginning-of-line)
	  (setq start (point))))
    (goto-char end)
    (skip-chars-backward " \t\n")
    (setq end (point)))
  (if oz-prepend-line
      (concat "\\line " (number-to-string (1+ (count-lines 1 start)))
	      " '" (or (buffer-file-name) (buffer-name)) "' % fromemacs\n"
	      (buffer-substring start end))
    (buffer-substring start end)))

(defun oz-normalize-file-name (file)
  ;; Collapse multiple slashes to one, to handle non-Emacs file names.
  (save-match-data
    ;; Use arg 1 so that we don't collapse // at the start of the file name.
    ;; That is significant on some systems.
    ;; However, /// at the beginning is supposed to mean just /, not //.
    (if (string-match "^///+" file)
	(setq file (replace-match "/" t t file)))
    (while (string-match "//+" file 1)
      (setq file (replace-match "/" t t file)))
    file))

(defun oz-find-buffer-or-file (name visit)
  ;; Try to find a buffer or file named NAME.
  ;; If VISIT is nil, only return an existing buffer,
  ;; else try to locate NAME on the file system.
  (or (get-buffer name)
      (find-buffer-visiting name)
      (and visit
	   (let ((find-file-run-dired nil))
	     (find-file-noselect (oz-normalize-file-name name))))))

(defun oz-match-string (num &optional string)
  ;; Return string of text matched by last search.
  ;; NUM specifies which parenthesized expression in the last regexp.
  ;; Value is nil if NUMth pair didn't match, or there were less than NUM
  ;; pairs.  Zero means the entire text matched by the whole regexp or whole
  ;; string.  STRING should be given if the last search was by `string-match'
  ;; on STRING.
  (if (match-beginning num)
      (if string
	  (substring string (match-beginning num) (match-end num))
	(buffer-substring (match-beginning num) (match-end num)))))

;;}}}
;;{{{ Run/Halt Oz

(defun run-oz ()
  "Run Mozart as a sub-process.
Handle input and output via the Oz Emulator buffer."
  (interactive)
  (save-excursion
    (oz-start-if-not-running))
  (oz-create-oz-buffer))

(defun oz-create-oz-buffer ()
  (or (eq major-mode 'oz-mode)
      (eq major-mode 'oz-gump-mode)
      (eq major-mode 'ozm-mode)
      (oz-new-buffer)))

(defun oz-halt (force)
  "Halt the Mozart sub-process.
With no prefix argument, feed an `{Application.exit 0}' statement and
wait for the process to terminate.  Waiting time is limited by variable
`oz-halt-timeout'; after this delay, the process is sent a SIGHUP if
still living.

With C-u as prefix argument, send the process a SIGHUP without delay.
With C-u C-u as prefix argument, send it a SIGKILL instead."
  (interactive "P")
  (if (oz-is-running)
      (progn
	(message "Halting Oz ...")
	(if (not force)
	    (let* ((i oz-halt-timeout)
		   (proc (get-buffer-process oz-emulator-buffer)))
	      (oz-send-string "{Application.exit 0}" t)
	      (while (and (eq (process-status proc) 'run)
			  (> i 0))
		(message "Halting Oz ... %s" i)
		(sleep-for 1)
		(setq i (1- i)))))
	(if (and (consp force)
		 (> (car force) 4))
	    (progn
	      (kill-process oz-emulator-buffer)
	      (message "Oz killed."))
	  (delete-process oz-emulator-buffer)
	  (message "Oz halted.")))
    (message "Oz is not running."))
  (cond ((get-buffer oz-temp-buffer)
	 (delete-windows-on oz-temp-buffer)
	 (kill-buffer oz-temp-buffer)))
  (oz-bar-remove)
  (setq oz-buffered-send-string nil)
  (oz-set-title oz-old-frame-title))

(defun oz-is-running ()
  (get-buffer-process oz-emulator-buffer))

(defun oz-start-if-not-running ()
  (if (not (oz-is-running))
      (progn
	(cond (oz-emulator-hook
	       (funcall oz-emulator-hook)
	       (oz-prepare-emulator-buffer
		(process-filter (get-buffer-process oz-emulator-buffer)) t))
	      (t
	       (setq oz-emulator-buffer "*Oz Emulator*")
	       (oz-make-comint oz-engine-program oz-root-functor)
	       (oz-prepare-emulator-buffer 'oz-filter t)))
	(oz-set-title oz-frame-title)
	(message "Oz started."))))

(defun oz-attach ()
  (let (host port)
    (cond ((>= (length command-line-args-left) 1)
	   (setq host oz-default-host
		 port (string-to-number (car command-line-args-left))
		 command-line-args-left (cdr command-line-args-left)))
	  (t
	   (error "Missing port argument to oz-attach")))
    (oz-make-comint (cons host port))
    (oz-prepare-emulator-buffer 'oz-filter nil)
    (process-kill-without-query (get-buffer-process oz-emulator-buffer))))

(defun oz-make-comint (program &rest switches)
  (if (get-buffer oz-emulator-buffer)
      (progn
	(delete-windows-on oz-emulator-buffer)
	(kill-buffer oz-emulator-buffer)))
  (apply 'make-comint "Oz Emulator" program nil switches))

(defun oz-prepare-emulator-buffer (filter show)
  (let ((proc (get-buffer-process oz-emulator-buffer)))
    (setq oz-emulator-filter-hook filter)
    (set-process-filter proc 'oz-emulator-filter))
  (if show
      (oz-buffer-show (get-buffer oz-emulator-buffer)))
  (bury-buffer oz-emulator-buffer))

(defun oz-socket (host port port2)
  (let ((bs oz-compiler-buffers) (newbs nil))
    (while bs
      (if (not (comint-check-proc (car bs)))
	  (kill-buffer (car bs))
	(setq newbs (cons (car bs) newbs)))
      (setq bs (cdr bs)))
    (setq oz-compiler-buffers newbs))
  (let ((buffer (generate-new-buffer "*Oz Compiler*")))
    (setq oz-compiler-buffers (cons buffer oz-compiler-buffers))
    (save-excursion
      (set-buffer buffer)
      (compilation-mode)
      (set (make-local-variable 'compilation-parse-errors-function)
	   'oz-compilation-parse-errors))
    (comint-exec buffer (buffer-name buffer) (cons host port) nil nil)
    (let ((proc (get-buffer-process buffer)))
      (process-kill-without-query proc nil)
      (set-process-filter proc 'oz-compiler-filter))
    (oz-buffer-show buffer)
    (bury-buffer buffer)
    (let ((xs oz-buffered-send-string))
      (setq oz-buffered-send-string nil)
      (while xs
	(oz-send-string (car (car xs)) (cdr (car xs)))
	(setq xs (cdr xs)))))
  (oz-server-open host port2))

;;}}}
;;{{{ Filtering Process Output

(defun oz-emulator-filter (proc string)
  ;; look for oz-socket:
  (let ((start 0))
    (while (string-match oz-socket-pattern string start)
      (let ((host (or (oz-match-string 2 string) oz-default-host))
	    (port (string-to-number (oz-match-string 3 string)))
	    (port2 (string-to-number (oz-match-string 4 string))))
	(setq start (match-beginning 0))
	(setq string (concat (substring string 0 start)
			     (substring string (match-end 0))))
	(save-excursion
	  (oz-socket host port port2)))))
  (funcall oz-emulator-filter-hook proc string))

(defun oz-compiler-filter (proc string)
  ;; look for oz-show-temp:
  (let ((start 0))
    (while (string-match oz-show-temp-pattern string start)
      (let ((filename (oz-normalize-file-name (oz-match-string 1 string))))
	(setq start (match-beginning 0))
	(setq string (concat (substring string 0 start)
			     (substring string (match-end 0))))
	(save-excursion
	  (let ((buf (or (get-buffer oz-temp-buffer)
			 (generate-new-buffer oz-temp-buffer))))
	    (oz-buffer-show buf)
	    (set-buffer buf))
	  (insert-file-contents filename t nil nil t)
	  (delete-file filename)
	  (cond ((string-match "\\.ozi$" filename) (oz-mode))
		((string-match "\\.ozm$" filename) (ozm-mode)))))))
  ;; look for oz-bar:
  (let ((start 0))
    (while (string-match oz-bar-pattern string start)
      (let ((file   (oz-match-string 1 string))
	    (line   (string-to-number (oz-match-string 2 string)))
	    (column (let ((c (oz-match-string 3 string)))
		      (if (string-equal c "~1")
			  -1
			(string-to-number c))))
	    (state  (oz-match-string 4 string)))
	(setq start (match-beginning 0))
	(setq string (concat (substring string 0 start)
			     (substring string (match-end 0))))
	(save-excursion
	  (set-buffer (process-buffer proc))
	  (oz-bar file line column state)))))
  (oz-filter proc string))

(defun oz-filter (proc string)
  (let ((old-buffer (current-buffer)))
    (unwind-protect
	(let (moving errs-found start-of-output)
	  (set-buffer (process-buffer proc))
	  (setq moving (= (point) (process-mark proc)))
	  (save-excursion
	    ;; insert the text, moving the process marker:
	    (goto-char (process-mark proc))
	    (setq start-of-output (point))
	    (insert-before-markers string)
	    (set-marker (process-mark proc) (point))

	    ;; look for error messages in output:
	    (goto-char start-of-output)
	    (setq errs-found
		  (and oz-popup-on-error
		       (re-search-forward oz-error-string nil t)
		       (match-beginning 0)))

	    ;; remove escape characters:
	    (goto-char start-of-output)
	    (while (re-search-forward oz-remove-pattern nil t)
	      (replace-match "" nil t)))

	  (if errs-found
	      (progn
		(oz-buffer-show (current-buffer))
		(set-window-start (get-buffer-window (current-buffer))
				  errs-found)
		(set-window-point (get-buffer-window (current-buffer))
				  errs-found))
	    (if moving
		(goto-char (process-mark proc)))))
      (set-buffer old-buffer))))

;;}}}
;;{{{ Buffers

(defun oz-buffer-show (buffer)
  (if (and buffer (not (get-buffer-window buffer)))
      (let ((win (or (get-buffer-window oz-emulator-buffer)
		     (let ((bs oz-compiler-buffers) com)
		       (while (and (not com) bs)
			 (setq com (get-buffer-window (car bs)))
			 (setq bs (cdr bs)))
		       com)
		     (get-buffer-window oz-temp-buffer)
		     (split-window (get-largest-window)
				   (/ (* (window-height (get-largest-window))
					 (- 100 oz-other-buffer-size))
				      100)))))
	(set-window-buffer win buffer)
	(set-buffer buffer)
	(set-window-point win (point-max))
	(bury-buffer buffer))))

(defun oz-toggle-compiler ()
  "Toggle visibility of the Oz Compiler window.
If the compiler buffer is not visible in any window, then display it.
If it is, then delete the corresponding window."
  (interactive)
  (oz-toggle-window oz-compiler-buffer))

(defun oz-toggle-emulator ()
  "Toggle visibility of the Oz Emulator window.
If the emulator buffer is not visible in any window, then display it.
If it is, then delete the corresponding window."
  (interactive)
  (oz-toggle-window oz-emulator-buffer))

(defun oz-toggle-temp ()
  "Toggle visibility of the Oz Temp window.
If the temporary buffer is not visible in any window, then show it.
If it is, then delete the corresponding window."
  (interactive)
  (oz-toggle-window oz-temp-buffer))

(defun oz-toggle-window (buffername)
  (let ((buffer (get-buffer buffername)))
    (if buffer
	(let ((win (get-buffer-window buffername)))
	  (if win
	      (save-excursion
		(set-buffer buffer)
		(if (= (window-point win) (point-max))
		    (delete-windows-on buffername)
		  (set-window-point win (point-max))))
	    (oz-buffer-show (get-buffer buffername)))))))

;;}}}
;;{{{ Feeding to the Compiler

(defun oz-zmacs-stuff ()
  (if (boundp 'zmacs-region-stays) (setq zmacs-region-stays t)))

(defun oz-feed-buffer ()
  "Feed the current buffer to the Oz Compiler."
  (interactive)
  (let ((file (buffer-file-name)))
    (if (and oz-prepend-line file (buffer-modified-p)
	     (y-or-n-p (format "Save buffer %s first? " (buffer-name))))
	(save-buffer))
    (if (and oz-prepend-line file (not (buffer-modified-p)))
	(oz-feed-file file)
      (oz-feed-region (point-min) (point-max))))
  (oz-zmacs-stuff))

(defun oz-feed-region (start end)
  "Feed the current region to the Oz Compiler."
  (interactive "r")
  (oz-send-string (oz-get-region start end))
  (oz-zmacs-stuff))

(defun oz-feed-line (arg)
  "Feed the current line to the Oz Compiler.
With ARG, feed that many lines.  If ARG is negative, feed that many
preceding lines as well as the current line."
  (interactive "p")
  (let ((region (oz-line-region arg)))
    (oz-feed-region (car region) (cdr region))))

(defun oz-feed-paragraph (arg)
  "Feed the current paragraph to the Oz Compiler.
If the point is exactly between two paragraphs, feed the preceding
paragraph.  With ARG, feed that many paragraphs.  If ARG is negative,
feed that many preceding paragraphs as well as the current paragraph."
  (interactive "p")
  (let ((region (oz-paragraph-region arg)))
    (oz-feed-region (car region) (cdr region))))

(if (memq system-type '(ms-dos windows-nt))
    (defun oz-encode-string (s)
      (encode-coding-string string buffer-file-coding-system))
  (defun oz-encode-string (s) s))

(defun oz-send-string (string &optional system)
  "Feed STRING to the Oz Compiler, restarting Mozart if it died.
If SYSTEM is non-nil, it is a command for the system and is to be
compiled using a default set of switches."
  (interactive "sString to feed: \nP")
  (oz-start-if-not-running)
  (if (not (get-buffer-process oz-compiler-buffer))
      (setq oz-buffered-send-string
	    (nconc oz-buffered-send-string (list (cons string system))))
    (let ((proc (get-buffer-process oz-compiler-buffer))
	  (eof (concat (char-to-string 4) "\n")))
      (save-excursion
	(set-buffer oz-compiler-buffer)
	(setq compilation-last-buffer (current-buffer))
	(setq oz-compiler-output-start
	      (marker-position
	       (process-mark (get-buffer-process (current-buffer)))))
	(setq compilation-error-list nil))
      (if system
	  (comint-send-string
	   proc
	   (concat "\\localSwitches\n"
		   "\\switch +threadedqueries -verbose "
		   "-expression -runwithdebugger\n"
		   (oz-encode-string string)))
	(comint-send-string proc (oz-encode-string string)))
      (comint-send-string proc "\n")
      (comint-send-string proc eof))))


(defun oz-to-coresyntax-buffer ()
  "Display the core syntax expansion of the current buffer."
  (interactive)
  (oz-to-coresyntax-region (point-min) (point-max)))

(defun oz-to-coresyntax-region (start end)
  "Display the core syntax expansion of the current region."
  (interactive "r")
  (oz-directive-on-region start end "+core -codegen"))

(defun oz-to-coresyntax-line (arg)
  "Display the core syntax expansion of the current line.
With ARG, feed that many lines.  If ARG is negative, feed that many
preceding lines as well as the current line."
  (interactive "p")
  (let ((region (oz-line-region arg)))
    (oz-to-coresyntax-region (car region) (cdr region))))

(defun oz-to-coresyntax-paragraph (arg)
  "Display the core syntax expansion of the current paragraph.
If the point is exactly between two paragraphs, feed the preceding
paragraph.  With ARG, feed that many paragraphs.  If ARG is negative,
feed that many preceding paragraphs as well as the current paragraph."
  (interactive "p")
  (let ((region (oz-paragraph-region arg)))
    (oz-to-coresyntax-region (car region) (cdr region))))

(defun oz-to-emulatorcode-buffer ()
  "Display the emulator code for the current buffer."
  (interactive)
  (oz-to-emulatorcode-region (point-min) (point-max)))

(defun oz-to-emulatorcode-region (start end)
  "Display the emulator code for the current region."
  (interactive "r")
  (oz-directive-on-region
   start end "-core +codegen +outputcode -feedtoemulator"))

(defun oz-to-emulatorcode-line (arg)
  "Display the emulator code for the current line.
With ARG, feed that many lines.  If ARG is negative, feed that many
preceding lines as well as the current line."
  (interactive "p")
  (let ((region (oz-line-region arg)))
    (oz-to-emulatorcode-region (car region) (cdr region))))

(defun oz-to-emulatorcode-paragraph (arg)
  "Display the emulator code for the current paragraph.
If the point is exactly between two paragraphs, feed the preceding
paragraph.  With ARG, feed that many paragraphs.  If ARG is negative,
feed that many preceding paragraphs as well as the current paragraph."
  (interactive "p")
  (let ((region (oz-paragraph-region arg)))
    (oz-to-emulatorcode-region (car region) (cdr region))))

(defun oz-directive-on-region (start end switches)
  ;; Applies a directive to the region.
  (oz-send-string (concat "\\localSwitches\n"
			  "\\switch " switches "\n"
			  (oz-get-region start end))))

(defun oz-browse-buffer ()
  "Feed the current buffer to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Browse."
  (interactive)
  (oz-browse-region (point-min) (point-max)))

(defun oz-browse-region (start end)
  "Feed the current region to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Browse."
  (interactive "r")
  (let ((contents (oz-get-region start end)))
    (oz-send-string (concat "{Browse\n" contents "}")))
  (oz-zmacs-stuff))

(defun oz-browse-line (arg)
  "Feed the current line to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Browse.
With ARG, feed that many lines.  If ARG is negative, feed that many
preceding lines as well as the current line."
  (interactive "p")
  (let ((region (oz-line-region arg)))
    (oz-browse-region (car region) (cdr region))))

(defun oz-browse-paragraph (arg)
  "Feed the current paragraph to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Browse.
If the point is exactly between two paragraphs, feed the preceding
paragraph.  With ARG, feed that many paragraphs.  If ARG is negative,
feed that many preceding paragraphs as well as the current paragraph."
  (interactive "p")
  (let ((region (oz-paragraph-region arg)))
    (oz-browse-region (car region) (cdr region))))

(defun oz-show-buffer ()
  "Feed the current buffer to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Show."
  (interactive)
  (oz-show-region (point-min) (point-max)))

(defun oz-show-region (start end)
  "Feed the current region to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Show."
  (interactive "r")
  (let ((contents (oz-get-region start end)))
    (oz-send-string (concat "{Show\n" contents "}")))
  (oz-zmacs-stuff))

(defun oz-show-line (arg)
  "Feed the current line to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Show.
With ARG, feed that many lines.  If ARG is negative, feed that many
preceding lines as well as the current line."
  (interactive "p")
  (let ((region (oz-line-region arg)))
    (oz-show-region (car region) (cdr region))))

(defun oz-show-paragraph (arg)
  "Feed the current paragraph to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Show.
If the point is exactly between two paragraphs, feed the preceding
paragraph.  With ARG, feed that many paragraphs.  If ARG is negative,
feed that many preceding paragraphs as well as the current paragraph."
  (interactive "p")
  (let ((region (oz-paragraph-region arg)))
    (oz-show-region (car region) (cdr region))))

(defun oz-inspect-buffer ()
  "Feed the current buffer to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Inspect."
  (interactive)
  (oz-inspect-region (point-min) (point-max)))

(defun oz-inspect-region (start end)
  "Feed the current region to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Inspect."
  (interactive "r")
  (let ((contents (oz-get-region start end)))
    (oz-send-string (concat "{Inspect\n" contents "}")))
  (oz-zmacs-stuff))

(defun oz-inspect-line (arg)
  "Feed the current line to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Inspect.
With ARG, feed that many lines.  If ARG is negative, feed that many
preceding lines as well as the current line."
  (interactive "p")
  (let ((region (oz-line-region arg)))
    (oz-inspect-region (car region) (cdr region))))

(defun oz-inspect-paragraph (arg)
  "Feed the current paragraph to the Oz Compiler.
Assuming it to contain an expression, enclose it by an application
of the procedure Inspect.
If the point is exactly between two paragraphs, feed the preceding
paragraph.  With ARG, feed that many paragraphs.  If ARG is negative,
feed that many preceding paragraphs as well as the current paragraph."
  (interactive "p")
  (let ((region (oz-paragraph-region arg)))
    (oz-inspect-region (car region) (cdr region))))

;;}}}
;;{{{ Oz Debugger

(defun oz-debugger (arg)
  "Start the Oz debugger.
With ARG, stop it instead."
  (interactive "P")
  (oz-send-string (if arg "{Ozcar.close}" "{Ozcar.open}") t))

(defun oz-breakpoint-at-point (arg)
  "Set breakpoint at current line.
With ARG, delete it instead."
  (interactive "P")
  (oz-breakpoint arg))

(defun oz-breakpoint (flag)
  (save-excursion
    (beginning-of-line)
    (let ((line (1+ (count-lines 1 (point)))))
      (oz-send-string
       (concat "{Ozcar.object bpAt('"
	       (or (buffer-file-name) (buffer-name))
	       "' " (int-to-string line) (if flag " false" " true") ")}") t))))

;;}}}
;;{{{ Other Tools

(defun oz-profiler (arg)
  "Start the profiler.
With ARG, stop it instead."
  (interactive "P")
  (oz-send-string (if arg "{Profiler.close}" "{Profiler.open}") t))

(defun oz-open-panel ()
  "Feed `{Panel.open}' to the Oz Compiler."
  (interactive)
  (oz-send-string "{Panel.open}" t))

(defun oz-open-distribution-panel ()
  "Feed `{DistributionPanel.open}' to the Oz Compiler."
  (interactive)
  (oz-send-string "{DistributionPanel.open}" t))

(defun oz-open-compiler-panel ()
  "Feed `{New CompilerPanel.'class' init(OPI.compiler) _}' to the Oz Compiler."
  (interactive)
  (oz-send-string "{New CompilerPanel.'class' init(OPI.compiler) _}" t))

;;}}}
;;{{{ Misc Goodies

(defun oz-feed-file (file)
  "Feed a file to the Oz Compiler."
  (interactive "fFeed file: ")
  (oz-send-string (concat "\\insert '" file "'")))

;;}}}
;;{{{ The oz-bar (used by Compiler Panel, Debugger and Profiler)

(make-face 'bar-running)
(set-face-foreground 'bar-running "white")
(set-face-background 'bar-running (if oz-is-color "#a0a0a0" "black"))

(make-face 'bar-running-here)
(set-face-foreground 'bar-running-here "#707070")
(set-face-background 'bar-running-here (if oz-is-color "#d0d0d0" "white"))

(make-face 'bar-runnable)
(set-face-foreground 'bar-runnable "white")
(set-face-background 'bar-runnable (if oz-is-color "#7070c0" "black"))

(make-face 'bar-runnable-here)
(set-face-foreground 'bar-runnable-here "#5050a0")
(set-face-background 'bar-runnable-here (if oz-is-color "#d0d0d0" "white"))

(make-face 'bar-blocked)
(set-face-foreground 'bar-blocked "white")
(set-face-background 'bar-blocked (if oz-is-color "#d05050" "black"))

(make-face 'bar-blocked-here)
(set-face-foreground 'bar-blocked-here "#d05050")
(set-face-background 'bar-blocked-here (if oz-is-color "#d0d0d0" "white"))

(defvar oz-bar-overlay nil)
(defvar oz-bar-overlay-here nil)

(defun oz-bar (file line column state)
  ;; Display bar at given line, load file if necessary.
  (if (string-equal state "exit")
      (progn
	(oz-bar-remove)
	(call-interactively 'save-buffers-kill-emacs))
    (if (string-equal file "")
	(oz-bar-remove)
      (let* ((buffer (oz-find-buffer-or-file file t))
	     (window (display-buffer buffer))
	     start1 end1 start2 end2)
	(save-excursion
	  (set-buffer buffer)
	  (save-restriction
	    (widen)
	    (goto-line line)
	    (setq start1 (point))
	    (save-excursion
	      (forward-line 1)
	      (setq end1 (point)))
	    (if (> column 0)
		(forward-char column))
	    (if (and (>= column 0) (looking-at oz-token-pattern))
		(setq start2 (match-beginning 0) end2 (match-end 0))
	      (setq start2 start1 end2 start1))
	    (or oz-bar-overlay
		(cond (oz-gnu-emacs
		       (setq oz-bar-overlay (make-overlay start1 end1)
			     oz-bar-overlay-here (make-overlay start2 end2))
		       (overlay-put oz-bar-overlay 'priority 17)
		       (overlay-put oz-bar-overlay-here 'priority 18))
		      (oz-lucid-emacs
		       (setq oz-bar-overlay (make-extent start1 end1)
			     oz-bar-overlay-here (make-extent start2 end2))
		       (set-extent-priority oz-bar-overlay 17)
		       (set-extent-priority oz-bar-overlay-here 18))))
	    (cond (oz-gnu-emacs
		   (move-overlay
		    oz-bar-overlay start1 end1 (current-buffer))
		   (move-overlay
		    oz-bar-overlay-here start2 end2 (current-buffer)))
		  (oz-lucid-emacs
		   (set-extent-endpoints
		    oz-bar-overlay start1 end1 (current-buffer))
		   (set-extent-endpoints
		    oz-bar-overlay-here start2 end2 (current-buffer))))
	    (or (string-equal state "unchanged")
		(oz-bar-configure state))))
	(save-selected-window
	  (let ((old-buffer (current-buffer)) old-pos)
	    (select-window window)
	    (set-buffer buffer)
	    (setq old-pos (point))
	    (if (or (< start1 (point-min)) (> start1 (point-max)))
		(widen))
	    (if (not (pos-visible-in-window-p start1))
		(progn
		  (goto-char start1)
		  (recenter (/ (1- (window-height)) 2))))
	    (if (pos-visible-in-window-p old-pos)
		(goto-char old-pos))
	    (set-buffer old-buffer)))))))

(defun oz-bar-configure (state)
  ;; Change color of bar while not moving it.
  (let ((face
	 (car (read-from-string (concat "bar-" state))))
	(face-here
	 (car (read-from-string (concat "bar-" state "-here")))))
    (cond (oz-gnu-emacs
	   (overlay-put oz-bar-overlay 'face face)
	   (overlay-put oz-bar-overlay-here 'face face-here))
	  (oz-lucid-emacs
	   (set-extent-face oz-bar-overlay face)
	   (set-extent-face oz-bar-overlay-here face-here)))))

(defun oz-bar-remove ()
  "Remove the bar marking an Oz source line."
  (interactive)
  (cond (oz-bar-overlay
	 (cond (oz-gnu-emacs
		(delete-overlay oz-bar-overlay)
		(delete-overlay oz-bar-overlay-here))
	       (oz-lucid-emacs
		(delete-extent oz-bar-overlay)
		(delete-extent oz-bar-overlay-here)))
	 (setq oz-bar-overlay nil)
	 (setq oz-bar-overlay-here nil))))

;;}}}
;;{{{ Testing Locally and Support for GDB

(defun oz-set-other (set-functor-path)
  "Set the value of environment variables OZEMULATOR resp. OZ_LOAD.
If SET-FUNCTOR-PATH is non-nil, set the functor search path (can also
be done via \\[oz-set-functor-path]); if it is nil, set the emulator
binary (can also be done via \\[oz-set-emulator])."
  (interactive "P")
  (if set-functor-path
      (call-interactively 'oz-set-functor-path)
    (oz-set-emulator)))

(defun oz-set-emulator ()
  "Set the value of variable `oz-emulator'.
This is the emulator used for debugging with gdb.
Can be selected by \\[oz-other-emulator]."
  (interactive)
  (setq oz-emulator
	(expand-file-name
	 (read-file-name (format "Oz Emulator binary (default %s): "
				 oz-emulator)
			 nil oz-emulator t nil)))
  (if (getenv "OZEMULATOR")
      (setenv "OZEMULATOR" oz-emulator)))

(defun oz-set-functor-path (arg)
  "Set the value of variable `oz-functor-path'.
Can be selected by \\[oz-other-functor-path]."
  (interactive "sOz functor search path: ")
  (setq oz-functor-path arg)
  (if (getenv "OZ_LOAD")
      (setenv "OZ_LOAD" oz-functor-path)))

(defun oz-other (set-functor-path)
  "Toggle between global and local Oz Emulator resp. Oz functors.
If SET-FUNCTOR-PATH is non-nil, toggle the functor search path (via
\\[oz-other-functor-path]); if it is nil, toggle the emulator binary
\(via \\[oz-other-emulator])."
  (interactive "P")
  (if set-functor-path
      (oz-other-functor-path)
    (oz-other-emulator)))

(defun oz-other-emulator ()
  "Toggle between global and local Oz Emulator.
The local emulator is given by the user option `oz-emulator';
see \\[oz-set-emulator]."
  (interactive)
  (cond ((getenv "OZEMULATOR")
	 (setenv "OZEMULATOR" nil)
	 (message "Oz Emulator: global"))
	(t
	 (setenv "OZEMULATOR" oz-emulator)
	 (message "Oz Emulator: %s" oz-emulator))))

(defun oz-other-functor-path ()
  "Toggle between global and local Oz functor search path.
The local functors are given by the user option `oz-functor-path';
see \\[oz-set-functor-path]."
  (interactive)
  (cond ((getenv "OZ_LOAD")
	 (setenv "OZ_LOAD" nil)
	 (message "Oz functor search path: global"))
	(t
	 (setenv "OZ_LOAD" oz-functor-path)
	 (message "Oz functor search path: %s" oz-functor-path))))

(defun oz-gdb ()
  "Toggle debugging of the Oz Emulator with gdb.
The emulator to use for debugging is set via \\[oz-set-emulator]."
  (interactive)
  (if (getenv "OZ_PI")
      t
    (setenv "OZ_PI" "1")
    (setenv "OZPATH"
	    (concat (or (getenv "OZPATH") ".") ":"
		    (oz-home) ":"
		    (oz-home) "/share")))
  (cond (oz-emulator-hook
	 (setq oz-emulator-hook nil)
	 (message "gdb disabled"))
	(t
	 (setq oz-emulator-hook 'oz-start-gdb-emulator)
	 (message "gdb enabled: %s" oz-emulator))))

(defun oz-start-gdb-emulator ()
  ;; Run the Oz Emulator under gdb.
  ;; This is hooked into the variable `oz-emulator-hook' via \\[oz-gdb].
  ;; The directory containing FILE becomes the initial working directory
  ;; and source-file directory for gdb.  If you wish to change this, use
  ;; the gdb commands `cd DIR' and `directory'.
  (let ((old-buffer (current-buffer))
	(init-str (concat "set args -u " oz-root-functor "\n")))
    (cond ((get-buffer oz-emulator-buffer)
	   (delete-windows-on oz-emulator-buffer)
	   (kill-buffer oz-emulator-buffer)))
    (cond (oz-gnu-emacs
	   (gdb (concat "gdb " oz-emulator)))
	  (oz-lucid-emacs
	   (gdb oz-emulator)))
    (setq oz-emulator-buffer (buffer-name (current-buffer)))
    (comint-send-string
     (get-buffer-process oz-emulator-buffer)
     init-str)
    (if oz-gdb-autostart
	(comint-send-string
	 (get-buffer-process oz-emulator-buffer)
	 "run\n"))
    (switch-to-buffer old-buffer)))

;;}}}
;;{{{ Application Development Support

(defvar oz-compile-history nil
  "History of commands used in oz-compile-file.")

(defun oz-compile-file (command)
  "Compile an Oz program non-interactively."
  (interactive (list (if (buffer-file-name)
			 (read-from-minibuffer "Oz compilation command: "
					       oz-compile-command nil nil
					       '(oz-compile-history . 1))
		       (error "Buffer has no file name"))))
  (setq oz-compile-command command)
  (let* ((file (buffer-file-name))
	 (real-command (format oz-compile-command (or file ""))))
    (if (and file (buffer-modified-p)
	     (y-or-n-p (format "Save buffer %s first? " (buffer-name))))
	(save-buffer))
    (compile-internal real-command "No more errors")))

(defvar oz-application-history nil
  "History of commands used in oz-debug-application.")

(defvar oz-application-name-pattern "\\`\\(.*\\)\\.ozg?\\'"
  "Regular expression matching a file name with an `.oz' or `.ozg' extension.
The first subexpression matches the file name without the extension.")

(defun oz-debug-application (command)
  "Invoke ozd."
  (interactive (list (if (oz-is-running)
			 (error "Only one Oz may be running")
		       (read-from-minibuffer "Oz application invocation: "
					     oz-application-command nil nil
					     '(oz-application-history . 1)))))
  (setq oz-application-command command)
  (let* ((file (buffer-file-name))
	 (app (if file
		  (if (string-match oz-application-name-pattern file)
		      (oz-match-string 1 file))))
	 (real-command (concat "ozd -E --opi -- "
			       (format oz-application-command (or app "")))))
    (oz-make-comint "/bin/sh" "-c" real-command)
    (oz-prepare-emulator-buffer 'oz-filter t)))

;;}}}
;;{{{ Oz-Machine Mode

(defconst ozm-keywords-matcher
  (concat "\\<\\("
	  "true\\|false\\|unit" "\\|"
	  "pos\\|pid\\|ht\\|onScalar\\|onRecord\\|cmi"
	  "\\)\\>"))

(defconst ozm-instr-matcher-1
  (concat
   "\t\\("
   (mapconcat
    'identity
    '("move" "moveMove"
      "allocateL" "createVariable" "createVariableMove" "putConstant"
      "putList" "putRecord" "setConstant" "setProcedureRef" "setValue"
      "setVariable" "setVoid" "getNumber" "getLiteral" "getList"
      "getListValVar" "getListVarVar" "getRecord" "unifyNumber" "unifyLiteral"
      "unifyValue" "unifyVariable" "unifyValVar" "unifyVoid" "unify" "branch"
      "callBI" "inlinePlus1?" "inlineMinus1?" "inlineDot" "inlineAt"
      "inlineAssign" "callGlobal" "callMethod" "call" "consCall" "deconsCall"
      "tailCall" "tailConsCall" "tailDeconsCall" "callProcedureRef"
      "callConstant" "sendMsg" "tailSendMsg" "exHandler" "testLiteral"
      "testNumber" "testRecord" "testList" "testBool" "testBI" "testLT"
      "testLE" "match" "getVariable" "getVarVar" "getVoid" "lockThread"
      "getSelf" "setSelf" "debugEntry" "debugExit" "globalVarname"
      "localVarname" "clear") "\\|")
   "\\)("))

(defconst ozm-instr-matcher-2
  (concat
   "\t\\("
   (mapconcat
    'identity
    '("allocateL[1-9]" "allocateL10" "deAllocateL" "deAllocateL[1-9]"
      "deAllocateL10" "return" "popEx" "skip" "profileProc")
    "\\|")
   "\\)$"))

(defconst ozm-definition-matcher
  "\t\\(definition\\|definitionCopy\\|endDefinition\\)(")

(defconst ozm-register-matcher
  "\\<\\(x\\|y\\|g\\)([0-9]+)")

(defconst ozm-label-matcher
  "^lbl(\\([A-Za-z0-9_]+\\|'[^'\n]*'\\))")

(defconst ozm-name-matcher
  "<N: [^>]+>")

(defconst ozm-builtin-name-matcher
  "\t\\(callBI\\|testBI\\)(\\([A-Za-z0-9_]+\\|'[^'\n]*'\\)")

(defconst ozm-font-lock-keywords-1
  (list (cons ozm-keywords-matcher 1)
	(list ozm-instr-matcher-1
	      '(1 font-lock-keyword-face))
	(list ozm-instr-matcher-2
	      '(1 font-lock-keyword-face))
	(list ozm-definition-matcher
	      '(1 font-lock-function-name-face))
	(cons ozm-name-matcher 'font-lock-string-face)))

(defconst ozm-font-lock-keywords ozm-font-lock-keywords-1)

(defconst ozm-font-lock-keywords-2
  (append (list (list ozm-register-matcher
		      '(1 font-lock-type-face))
		(cons ozm-label-matcher 'font-lock-reference-face)
		(list ozm-builtin-name-matcher
		      '(2 font-lock-variable-name-face)))
	  ozm-font-lock-keywords-1))

(defun ozm-set-font-lock-defaults ()
  (set (make-local-variable 'font-lock-defaults)
       '((ozm-font-lock-keywords ozm-font-lock-keywords-1
	  ozm-font-lock-keywords-2)
	 nil nil nil beginning-of-line)))

(defun ozm-mode ()
  "Major mode for displaying Oz machine code.

Commands:
\\{oz-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map oz-mode-map)
  (setq major-mode 'ozm-mode)
  (setq mode-name "Oz-Machine")
  (oz-mode-variables)
  (ozm-set-font-lock-defaults)
  (if (and oz-want-font-lock window-system)
      (font-lock-mode 1)))

;;}}}

(provide 'mozart)

;;; Local Variables: ***
;;; mode: emacs-lisp ***
;;; byte-compile-dynamic-docstrings: nil ***
;;; byte-compile-compatibility: t ***
;;; End: ***
