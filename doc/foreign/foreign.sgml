<!DOCTYPE Book SYSTEM "ozdoc.dtd" [

<!-- Extension to the DTD -->
<!ENTITY % p.mix.local "|Em">
<!ELEMENT Em - - (#PCDATA)>
<!ENTITY % proglang.values.local "|lambda">
<!ENTITY % picture.element "picture|picture.extern|picture.choice">
<!ELEMENT comic - O (%picture.element;)>

<!-- Abbreviations -->
<!ENTITY lt "<">
<!ENTITY gt ">">
<!ENTITY Oz "Oz">
<!ENTITY ampersand "&">

<!-- Processing Instructions -->
<!ENTITY nbsp PI "nbsp">
<!ENTITY ellipsis PI "ellipsis">
<!ENTITY slash PI "slash">
<!ENTITY ie PI "ie">
<!ENTITY resp PI "resp">
<!ENTITY eg PI "eg">
<!ENTITY etc PI "etc">
<!ENTITY LaTeX PI "LaTeX">

]>

<Book proglang=oz>
  <Front>
    <Meta name=ozversion value="3.0">
    <Meta name=status value=revised>
    <Meta name=latex.package value="oz">
    <Meta name=latex.package value="pstricks">
    <Meta name=latex.package value="rotate">
    <Meta name=latex.package value="pifont">

    <meta name="html.split" value="chapter.intro">
    <meta name="html.split" value="sec.foreignex">
    <meta name="html.split" value="chapter.cpart">
    <meta name="html.split" value="chapter.unixdll">
    <meta name="html.split" value="chapter.windll">
    <meta name="html.split" value="chapter.tuning">
    <meta name="html.split" value="sec.cinterfacespec">
    <meta name="html.split" value="chapter.extension">

    <meta name="html.split.index" value="">

    <Title/Interfacing to C and C++/
     <Author.Extern to="author.db" key="Michael.Mehl">
     <Author.Extern to="author.db" key="Tobias.Mueller">
     <Author.Extern to="author.db" key="Christian.Schulte">
     <Author.Extern to="author.db" key="Ralf.Scheidhauer">
    <Abstract>
    &Oz; provides a simple yet powerful interface to dynamically link
native C and C++ code to &Oz;. It provides for
access and conversion from most &Oz; values to C data structures and
vice versa and supports mechanisms to handle suspension for C(++)
functions.
    </Abstract>
  <Body proglang=cc>
<chapter id=chapter.intro>
<title/Introduction/
<p>
&Oz; provides a simple yet powerful interface to dynamically link
native C and C++ code to &Oz;<note foot>Dynamic linking is currently
not supported on the AIX/RS6000 platform.</note>. It provides for
access and conversion from most &Oz; values to C data structures and
vice versa and supports mechanisms to handle suspension for C(++)
functions.
<p>
The usage of the C and C++ interface is first explained using an
example followed by a reference part that describes the interface in
detail.
</chapter>

<chapter id=sec.foreignEx><title/A small Example/
<p>
<figure class="Program" id=getenvC>
<caption/File <file/getenv.cc/: a C++ program to provide a getenv for &Oz;/
<code display >
<![RCDATA[
#include "mozart.h"                                  // 1
                                                     // 2
OZ_BI_define(BIgetenv,1,1)                           // 3
{                                                    // 4
  OZ_declareAtom(0,envVarName);                      // 5
                                                     // 6
  char *envValue = getenv(envVarName);               // 7
                                                     // 8
  if (envValue == 0) /* not defined in environment */// 9
    return OZ_FAILED;                                //10
                                                     //11
  OZ_RETURN_ATOM(envValue);                          //12
} OZ_BI_end                                          //13
                                                     //14
                                                     //15
OZ_C_proc_interface oz_interface[] = {               //16
  {"getenv",1,1,BIgetenv},                           //17
  {0,0,0,0}                                          //18
};                                                   //19
                                                     //20
OZ_C_proc_interface *oz_init_module() {              //21
  return oz_interface;                               //22
}                                                    //23
]]>
</code>
</figure>

<p>

Suppose we want to provide an &Oz; native module <<Goodies>>
containing a single procedure <<{Goodies.getenv VarA ValueA}>> as an
interface to the C library function <code /getenv(3)/: it constrains
<<ValueA>> to an atom, which is the value of the environment variable
<<VarA>>, where <<VarA>> is an atom. Thus
<<{Goodies.getenv 'HOME' X}>> will constrain <<X>> to an atom
representing the path to our home directory.

To realize this we have to perform the following steps:
<LIST ENUM>
<ITEM> Write a piece of C code.
<ITEM> Create an object file from the C code.
<ITEM> Create a dynamic library from the object file(s).
<ITEM> Link the library into Oz.
</LIST>
These steps are explained in more detail below.
<p>
</chapter>

<chapter id=chapter.cpart><title/The C Part/
<p>
<ptr to=getenvC> shows a first attempt to provide access to the
<code /getenv/ C library function as explained above. In the following
we will go through it in detail and successively improve it.
<p>
Every C program that will be linked to &Oz; must include the header file
<file/mozart.h/  (line 1 in  <ptr to=getenvC>), which is located in
the <file/include/ subdirectory of the &Oz; installation directory. It
contains the definition of the data structures and functions used to
interface C to &Oz;. All these data structures start with <<OZ_>>
such that they will not clash with the user's name space.
<p>
To declare a C function that can be used from &Oz; you have to enclose
its declaration into the macros
<code /OZ_BI_define(?{name},?{inarity},?{outarity})/
<index class=module/OZ_BI_define/
and <code /OZ_BI_end/
<index class=module/OZ_BI_end/. The following code fragment declares a
C-function <code /BIgetenv/ <index class=module/BIgetenv/
for inclusion into Oz, which has one input an one output argument:
<p>
<code display/
OZ_BI_define(BIgetenv,1,1)
{
  ...
} OZ_BI_end
/
<p>
&Oz; represents data like strings, integers, floats, etc. different
than C. For this reason <file/mozart.h/ provides type testing
functions and routines to convert from the C into the &Oz;
representation and vice versa. All &Oz; values are summarized in one
abstract C data type called <code /OZ_Term/ <index
class=module/OZ_Term/.
<p>
To signal whether the call to a C function was successful or not it
must return a value of type <code /OZ_Return/<index
class=module/OZ_Return/, which may be <code /OZ_FAILED/<index
class=module/OZ_FAILED/ (in which case failure will occur), <code
/OZ_ENTAILED/<index class=module/OZ_ENTAILED/ to signal successful
completion. <code /OZ_Return/ also contains several other values,
which are not visible to the user. They are only used for internal
purposes, for example to handle suspension or raising exceptions.
<p>
In line 5 we use the macro <code /OZ_declareAtom(n,name)/: it checks
whether the <code /n/-th input argument is an atom and declares
a new C++ variable of type <code /char*/ with name <code /name/. So
line 5 declares <code /envVarName/ which holds the C++ string
representation of the first and only input argument.
<p>
In line 7 we declare a C++ variable <code /envValue/ which will
temporarily hold the return value of <code /BIgetenv/.
<p>
In lines 9--11 of <ptr to=getenvC> we check whether an environment
variable of the requested name exists and return <code /OZ_FAILED/
if not.
<p>
Line 19 loads the result into the output argument of <code /BIgetenv/
using the macro <code /OZ_RETURN_ATOM/: it converts its argument to an
&Oz; atom assigns the first output register to that value and leaves
the function with <code /OZ_ENTAILED/ signalling that the call to
<code /BIgetenv/ was success full.
<p>
Lines 16--23 in <ptr to=getenvC> are needed for the linking step and
will be explained in <ptr to=sec.foreignLink>.


</chapter>

    <chapter id=chapter.unixdll>
      <title/Creating a DLL/
<section id=chapter.compiling><title>Compiling the C program</title>
<p>
TODO: need to provide special options to the C compiler

</section>
<section id=chapter.linking><title>Creating a dynamic library</title>
<p>
TODO: need to provide special options to the linker

</section>
<section id=sec.foreignLink><title>Linking a native module</title>
<p>
In the last step we make the native module available by linking
it into &Oz;. Lines 16--23 in <ptr to=getenvC> are needed to
declare the export signature of the native module. A function named <code
/oz_init_module/ must be exported by every native module: this
function will be called when the module is linked into &Oz;. It can be
used to do some module dependent initialization and has to return an
array whose elements are of type <code /OZ_C_proc_interface/; the end
of the array must be terminated by an empty structure. The array describes
the signature of the functions being exported from the module:
<code display >
<![RCDATA[
typedef struct {
  const char * name;
  short        inArity;
  short        outArity;
  OZ_CFun      func;
} OZ_C_proc_interface;
]]>
</code>

<code /name/ is string describing the name by which the native
function will be accessible from Oz (see below). <code /inArity/ and
<code /outArity/ specify the number of input and output
arguments. <code /func/ is a pointer to the function being exported.
<p>
Now we can link our module into &Oz; by executing:

<code display proglang=oz>
declare
[Goodies]={Module.link ['./goodies.so{native}']}
</code>

This will lazily load the module upon first access and bind
<<Goodies>> to a record with a single (since we exported only one
function) feature named <<getenv>> (this is derived from the value of
the <code /name/ field of <code /OZ_C_proc_interface/). Now we can call
it like this:

<code display proglang=oz>
{Browse {Goodies.getenv 'HOME'}}
</code>

<p>
</section>
</chapter>
<chapter id=chapter.windll><title>Creating object files under Windows 95/NT</title>
<p>
TODO: check this
<p>
Currently there is no <code/oztool/ available for Windows 95/NT to
compile and create a DLL (dynamic link library). Consult your C compilers
documentation on how to create DLLs. When loading a DLL, &Oz; will
automatically call a C function named <code /OZ_linkFF/ to do a certain
special linking step needed on the Windows platform. This function is
defined in the file <code /mozart.c/ contained in the <code /include/
subdirectory of the &Oz; installation directory. So you have to compile
<code /mozart.c/ and include it into the DLL. You also have to explicitely
export all the functions you want to call from &Oz; (including
<code /OZ_linkFF/) from the DLL.
<p>
Dynamic linking has been testet using Watcom version 10.6 and MS
Visual C++ version 4.0. In the following we shortly describe how to
proceed on each of these compilers to create the DLL named
<code /getenv.dll/ for the example above.
<p>
TODO:
For some strange reason that I don't know the DLL has to have the
suffix <code /.so-win32-i486/. So after you've created <code
/getenv.dll/ as described below, rename it to <code
/getenv.so-win32-i486/ which then can be loaded into &Oz; as described
above.



<section><title/Watcom/
<p>
TODO: check whether this works
<p>
First create a file named <code /getenv.lnk/ with the following contents:
<code display >
system nt_dll initinstance terminstance
export _BIgetenv
export _OZ_linkFF
file getenv,oz
</code>
Note that you have to prepend a <code /_/ to each of the functions,
that you want to export.
<p>
Then compile the source files and create the DLL using the following
commands:
<code display >
wcc386 -zq -bd mozart.c
wcc386 -zq -bd getenv.cc
wlink @getenv
</code>
</section>

<section><title/Microsoft Visual C++/
<p>
TODO: check whether this works
<p>
First create a file named <code /getenv.def/ with the following contents:
<code display >
LIBRARY getenv
EXPORTS
  OZ_linkFF
  BIgetenv
</code>
<p>
Compilation and creation of the DLL is done using the following commands:
<code display >
cl /c mozart.c getenv.cc
link /def:getenv.def /dll oz.obj getenv.obj
</code>
</section>
</chapter>

<chapter id=chapter.tuning><title/Tuning the Example/
<p>

<para><title/Raising Exceptions/
In line 10 the program simply returns <code /OZ_FAILED/ if
the environment variable is not defined, which is not good programming
style. It should better raise an exception. This can be done using
<code display >
OZ_Return OZ_raise(OZ_Term t);
</code>
which raises the exception <code /t/. In our example we should replace
line 10 with something like
<code display >
 return OZ_raise(OZ_atom("envVarNotDefined"));
</code>
We leave as an exercise to the reader to give more informative
exception, &eg; adding the name of the undefined variable.

<para><title/Raising type errors/
Furthermore an extra function is provided for raising type errors. The
macro <code /OZ_declareAtom/ used in our example makes use of this function.
Type errors can be signaled using
<code display >
OZ_Return OZ_typeError(int pos, char *expectedType);
</code>
This is an exception signaling that the argument at position <code /pos/
is incorrect and the name of the expected type is <code /expectedType/.

<para id=sec.suspensionC><title/Suspension of C functions/
<index/suspension of C functions/
The macro <code /OZ_declareAtom/ internally also makes use of facilities
that allow C functions to suspend the running thread on variables.
Thus <code /OZ_declareAtom/ uses some code of the following form:
<code display >
if (OZ_isVariable(envVarName)) {
  OZ_suspendOn(envVarName);
}
</code>
<p>
If <code /envVarName/ is an unconstrained variable then
<code /OZ_suspendOn/ is called. <code /OZ_suspendOn/ is a macro that takes
a variable as argument and suspends the current thread. If the
variable is determined the suspended thread becomes runnable in which
case it will reexecute the C function <em/from the beginning/.
<p>
The application
  <code display proglang=oz>
declare X in {Browse {Goodies.getenv X}}
>>>
will call the C function as above. But the first argument is
detected as variable and the executing thread suspends.
<p>
If we feed
<<<
X='HOME'
>>>
the C function <code /BIgetenv/ is called again from the beginning and
the browser updates the display of the value of the environment
variable as expected.
<p>
</chapter>

<chapter id=sec.CInterfaceSpec><title/Specification of the C interface/
<p>
Below we give a reference of the functionality provided by the C and C++
interface.

<section><title/General Remarks/
<p>
Before we go into more detail we start with some general remarks.
<p>
Several functions of the interface rely on the fact that their
arguments are of a certain type. For example
<code display  >
char *OZ_atomToC(OZ_Term t)
</code>
expects <code /t/ to be an &Oz; atom and returns a string representing the
print name of <code /t/. In case <code /t/ is not an atom, the behaviour
of <code /OZ_atomToC/ is undefined and it will typically crash the
whole system.
<p>
If not stated otherwise all functions that return pointers into
memory, return a pointer to a memory area that is allocated <em/statically/.
This provides highest flexibility and efficiency. For
example the string returned by <code /OZ_atomToC/ must not be
overwritten by the user and the next call to any of the interface
functions may modify it.  So the user should take care to make a
copy of these memory blocks if necessary and free it again himself.
<p>
<section><title/Data types/
<p>
The following data types are defined in the interface:
<list>
<entry><<OZ_Return>>
<synopsis>
<code >typedef enum {OZ_FAILED=0, OZ_ENTAILED=1, ... } OZ_Return;</code>
<item>Return values for C functions to be interfaced to Oz.
<entry><<OZ_CFun>>
<synopsis>
<code >typedef OZ_Return (*OZ_CFun)(OZ_Term *,int *)</code>
<item>Signature of an interface function.
<entry><<OZ_Term>>
<synopsis>
<code >typedef ... OZ_Term;</code>
<item>This is the <em>abstract</em> data type for &Oz; values.
<entry><<OZ_C_proc_interface>>
<synopsis>
<code >
typedef struct {
  const char * name;
  short        inArity;
  short        outArity;
  OZ_CFun      func;
} OZ_C_proc_interface;
</code>
<item>This structure declares the signature of a function being
exported from a native module.
</list>
</section>

<section><title/Declaration/
<p>

<list>
<entry><<OZ_BI_define>>
<entry><<OZ_BI_end>>
<synopsis>
<index class=module/OZ_BI_define/
<index class=module/OZ_BI_end/
<code >
  OZ_BI_define(Name,InArity,OutArity)
  ... C/C++ code
  OZ_BI_end
</code>
<item>Every foreign function imported to &Oz; has to be declared using this
  pattern.  <code /Name/ is the name of the function being
  defined. <code /InArity/ and <code /OutArity/ specify the number of
  input and output arguments the function expects.

</list></section>


<section><title/Accessing arguments/
<subsection><title/Accessing input arguments/
<p>

<list>

<!--  <entry/<<OZ_in(n)>>/ -->
<!--  <synopsis> -->
<!--  <index class=module/OZ_in/ -->
<!--  <item> Abstract access to input argument number <code /n/ (counting -->
<!--  starts with 0) is provided through this macro. It returns a value of -->
<!--  type <code /OZ_Term/. The use of this macro is discouraged. You should -->
<!--  use one of the macros below. -->

<entry/<<OZ_declareTerm(n,var)>>/
<item> Declares a new variable of type <code /OZ_Term/ named <code
/var/, which is initialized with the value of the <code /n/-th
(counting starts from zero) input argument.

<entry/<<OZ_declareDetTerm(n,var)>>/
<item> Works like <code /OZ_declareTerm/ but additionally suspends if
the input argument is a free variable.

<entry/<<OZ_declareInt(n,var)>>/
<item> The function expects in input argument number <code /n/ an Oz
integer. It then declares a variable named <code /var/ of type <code
/int/ and initializes <code /var/ with the value of this argument. The
macro raises an exception if the argument is ill typed and suspends if
the argument is an unbound variable.

<entry/<<OZ_declareFloat(n,var)>>/
<item>Works like <code /OZ_declareInt/ but expectes an Oz float and
declares a variable of type <code /double/.

<entry/<<OZ_declareAtom(n,var)>>/
<item>Works like <code /OZ_declareInt/ but expectes an Oz atom and
declares a variable of type <code /char */.

<entry/<<OZ_declareVirtualString(n,var)>>/
<item>Works like <code /OZ_declareInt/ but expectes an Oz virtual
string and declares a variable of type <code /char */.

<entry/<<OZ_declareVS(n,var,len)>>/
<item> Like <code /OZ_declareVirtualString/, but additionally sets
<code /len/ to the size of the result.

<entry/<<OZ_declareBool(n,var)>>/
<item> Declares a variable of type <code /int/ named <code /var/,
which is non-zero iff the <code /n/-th argument is equal to <<true>>.

</list>

The above macros always declare a new C variable and then do some
checks. Therefor in C (not in C++) only one of them can be used only
at the start of a new block statement. For this reason there is also a
second set of macros named <code /OZ_set*/ that expect that their
second argument has already been declared. Thus in C++ you can use
<p>
<code>
  OZ_declareAtom(0,mystring);
  OZ_declareInt(1,myint);
</code>
<p>
whereas in plain C you have to write
<p>
<code>
  char *mystring;
  int myint;
  OZ_setAtom(0,mystring);
  OZ_setInt(1,myint);
</code>


</subsection>

<subsection><title/Accessing output arguments/
<p>
<list>
<entry/<<OZ_out(n)>>/
<synopsis>
<index class=module/OZ_out/
<item> Abstract access to output argument number <code /n/ (counting
starts with 0). Should only be used for writing an output argument and
never for reading. Usage is like
<p>
<code >
  OZ_out(3) = OZ_atom("myResult");
</code>
<p>
This macro should only be used in case a function returns more than
one value. For returning values in the first output argument one of
the functions below should be used.

<entry/<<OZ_RETURN(V)>>/
<synopsis>
<index class=module/OZ_RETURN/
<item> Returns from the C function with output value <<V>>. It is a
macro which expands to
<p>
<code>
  return (OZ_out(0)=V,OZ_ENTAILED)
</code>
</list>

For convenience we also provide the following macros:

<list>
<entry/<<OZ_RETURN_INT(I)>>/
<synopsis>
<index class=module/OZ_RETURN_INT/
<item> Return a C integer. Expands to
<code>OZ_RETURN(OZ_int(I))</code>

<entry/<<OZ_RETURN_ATOM(A)>>/
<synopsis>
<index class=module/OZ_RETURN_ATOM/
<item> Return a C integer. Expands to
<code>OZ_RETURN(OZ_atom(A))</code>

<entry/<<OZ_RETURN_STRING(S)>>/
<synopsis>
<index class=module/OZ_RETURN_STRING/
<item> Return a C integer. Expands to
<code>OZ_RETURN(OZ_string(S))</code>

<entry/<<OZ_RETURN_BOOL(X)>>/
<synopsis>
<index class=module/OZ_RETURN_BOOL/
<item> Returns <<false>> if  X equals to 0, <<true>>
otherwise. Expands to
<code>OZ_RETURN((X)?OZ_true():OZ_false())</code>


</list>

</subsection>
</section>

<section><title/Type testing/
<p>
To check whether a given <code /OZ_Term/ is a certain &Oz; value several
functions are provided:
<list>
<entry><<OZ_isAtom>>
<entry><<OZ_isBool>>
<entry><<OZ_isCell>>
<entry><<OZ_isThread>>
<entry><<OZ_isPort>>
<entry><<OZ_isChunk>>
<entry><<OZ_isDictionary>>
<entry><<OZ_isCons>>
<entry><<OZ_isFalse>>
<entry><<OZ_isFeature>>
<entry><<OZ_isFloat>>
<entry><<OZ_isInt>>
<entry><<OZ_isBigInt>>
<entry><<OZ_isSmallInt>>
<entry><<OZ_isNumber>>
<entry><<OZ_isLiteral>>
<entry><<OZ_isName>>
<entry><<OZ_isNil>>
<entry><<OZ_isObject>>
<entry><<OZ_isPair>>
<entry><<OZ_isPair2>>
<entry><<OZ_isProcedure>>
<entry><<OZ_isRecord>>
<entry><<OZ_isTrue>>
<entry><<OZ_isTuple>>
<entry><<OZ_isUnit>>
<entry><<OZ_isValue>>
<entry><<OZ_isVariable>>
<entry><<OZ_isBitString>>
<entry><<OZ_isByteString>>
<synopsis>
All these functions have the same signature. For
example <code /OZ_isAtom/ is declared as
<code >int OZ_isAtom(OZ_Term t)</code>
<item>
All type tests return nonzero iff their argument is of the respective type.
<p>
A few of these need some more explanation:
<p>

<code >int OZ_isBigInt(OZ_Term t)
int OZ_isSmallInt(OZ_Term t)</code>
<p>
The emulator has two representations for integers: small integers
and big integers. Small integers are implemented very efficiently.
<p>
<index class=module/OZ_isPair/
<code >int OZ_isPair(OZ_Term t)</code><p>
Returns zero iff <code /t/ is a tuple with label <<#>>.
<p>
<index class=module/OZ_isPair2/
<code >int OZ_isPair2(OZ_Term t)</code><p>
Returns nonzero iff <code /t/ is a tuple with label <<#>> and arity of 2.
<p>
<index class=module/OZ_isValue/
<code >int OZ_isValue(OZ_Term t)</code><p>
Returns nonzero iff <code /t/ is not a variable.
<p>
<index class=module/OZ_isVar/
<code>int OZ_isVariable(OZ_Term t)</code><p>
Returns nonzero iff <code /t/ is a variable.

<entry><<OZ_isList>>
<synopsis>
  <code>int OZ_isList(OZ_Term term, OZ_Term *var)</code>
<item>Returns nonzero iff <code /term/ is a list.  If <code /term/ is no
    list, but the tail is a variable, then <code /*var/ is set to the
    tail of the list, else it is set to null.  <code /var/ may be null.
    If <code /term/ is cyclic then <code /OZ_isList/ never terminates!

<entry><<OZ_isString>>
<synopsis>
  <code>int OZ_isString(OZ_Term term, OZ_Term *var)</code>
<item>Returns nonzero iff <code /term/ is an &Oz; string.  If <code /term/ is
    no string, but the tail or an element of the list is a variable,
    then <code /*var/ is set to this variable, else it is set to null.
    <code /var/ may be null.  If <code /term/ is cyclic then
      <code /OZ_isString/ never terminates!

<entry><<OZ_isVirtualString>>
<synopsis>
  <code >int OZ_isVirtualString(OZ_Term term, OZ_Term *var)</code>
<item>Returns nonzero iff <code /term/ is a virtual string.  If
    <code /term/ is no virtual string, but contains a variable, then
    <code /*var/ is set to this variable, else it is set to null.
      <code /var/ may be null.  If <code /term/ is cyclic then
      <code /OZ_isVirtualString/ never terminates!

<entry><<OZ_termType>>
<synopsis>
  <code>OZ_Term OZ_termType(OZ_Term t)</code>
<item>
Returns an atom describing the type of <code /t/. The following types
    are returned:
<<<
variable, int, float, atom, name, tuple, record, fset,
foreignPointer, procedure, cell, space, object, port,
chunk, array, dictionary, lock class, resource
>>>
    (see also <<Value.type>> in
<ptr.extern to="ozdoc:base" key="section.values.status">).
</list></section>
<section><title/Conversion/
<p>
The following functions are used to convert from &Oz; values to C data
structures and vice versa.
<list>

<entry><<OZ_atom>>
<synopsis>
<code >OZ_Term OZ_atom(char *s)</code>
<item>Converts C string <code /s/ to an &Oz; atom.

<entry><<OZ_atomToC>>
<synopsis>
<code >char *OZ_atomToC(OZ_Term t)</code>
<item>Converts &Oz; atom <code /t/ to a C string.

<entry><<OZ_int>>
<synopsis>
<code >OZ_Term OZ_int(int i)</code>
<item>Converts C integer <code /i/ to an &Oz; integer.

<entry><<OZ_intToC>>
<synopsis>
<code >int OZ_intToC(OZ_Term t)</code>
<item> Converts &Oz; integer <code /t/ to a C integer. If the &Oz; integer doesn't
  fit into the C integer, the maximal resp. minimal C integer values
  are used.

<entry><<OZ_parseInt>>
<synopsis>
  <code >char *OZ_parseInt(char *s)</code>
<item>Parse <code /s/ as an &Oz; integer.  Returns a pointer to the next
    character after the integer or null if <code /s/ does not start
    with an integer in &Oz; syntax (see <ptr.extern to="ozdoc:notation">).

<entry><<OZ_CStringToInt>>
<synopsis>
  <code >OZ_Term OZ_CStringToInt(char *s)</code>
<item>Converts C string <code /s/ to an &Oz; integer. <code /s/ must be a valid
  integer in &Oz; syntax (see <ptr.extern to="ozdoc:notation">).

<entry><<OZ_floatToC>>
<synopsis>
<code >double OZ_floatToC(OZ_Term t)</code>
<item>Converts &Oz; float <code /t/ to a C float.

<entry><<OZ_float>>
<synopsis>
<code >OZ_Term OZ_float(double f)</code>
<item>Converts C float <code /f/ to an &Oz; float.

<entry><<OZ_boolToC>>
<synopsis>
<code >int OZ_boolToC(OZ_Term t)</code>
<item>Returns non-zero iff <code /t/ is equal to <<true>>.

<entry><<OZ_parseFloat>>
<synopsis>
<code >char *OZ_parseFloat(char *s)</code>
<item>Parse <code /s/ as an &Oz; float. Returns a pointer to the next
  character after the float or null if <code /s/ is not an
  float in &Oz; syntax (see <ptr.extern to="ozdoc:notation">).

<entry><<OZ_CStringToFloat>>
<synopsis>
<code >OZ_Term OZ_CStringToFloat(char *s)</code>
<item>Converts C string <code /s/ to an &Oz; float. <code /s/ must be a valid
  float in &Oz; syntax (see <ptr.extern to="ozdoc:notation">).

<entry><<OZ_CStringToNumber>>
<synopsis>
<code >OZ_Term OZ_CStringToNumber(char *s)</code>
<item> Converts C string <code /s/ to an &Oz; number. <code /s/ must be a valid
  integer or float in &Oz; syntax (see <ptr.extern to="ozdoc:notation">).

<entry><<OZ_toC>>
<synopsis>
  <code >char *OZ_toC(OZ_Term t, int depth, int width)</code>
<item>Converts any &Oz; term <code /t/ to an C string.  This functions
    doesn't check for cycles.  A <code /depth/ of ?{n} means that trees
    are printed to a depth limit of ?{n} only, deeper subtrees are
    abbreviated by ,,,.  A <code /width/ of ?{n} means that for lists at
    most ?{n} elements and for records at most ?{n} fields are printed,
    the unprinted elements and fields are printed by ,,,.

<entry><<OZ_string>>
<synopsis>
<code >OZ_Term OZ_string(char *s)</code>
<item>Converts C string <code /s/ to an &Oz; string.

<entry><<OZ_stringToC>>
<synopsis>
<code >char *OZ_stringToC(OZ_Term t, int *n)</code>
<item>Converts &Oz; string <code /t/ to a C string and returns in
<code /n/ the length of string.

<entry><<OZ_virtualStringToC>>
<synopsis>
<code >char *OZ_virtualStringToC(OZ_Term t, int *n)</code>
<item>Converts &Oz; virtual string <code /t/ to a C string.
</list></section>
<section id=section.term_access><title/Term access and construction/
<p>
Several functions are available to access and construct terms.
<list>

<entry><<OZ_label>>
<synopsis>
<code >OZ_Term OZ_label(OZ_Term term)</code>
<item>Returns the label of <code /term/.

<entry><<OZ_width>>
<synopsis>
  <code >int OZ_width(OZ_Term term)</code>
<item>Returns the width of <code /term/.

<entry><<OZ_tuple>>
<synopsis>
  <code >OZ_Term OZ_tuple(OZ_Term label, int width)</code>
<item>Returns a new tuple with label <code /label/ and width <code /width/.
    Note that the values of all subtrees are still undefined. Hence a
    call to this function should be immediately followed by calls to
    <code /OZ_putArg/.

<entry><<OZ_putArg>>
<synopsis>
  <code >int OZ_putArg(OZ_Term tuple,int pos,OZ_Term arg)</code>
<item>Destructively sets the subtree of tuple <code /tuple/ at <code /pos/ to
    <code /arg/. The tuple arguments are numbered starting from 0.
    Should be only used for tuples created with <code /OZ_tuple/.

<entry><<OZ_mkTuple>>
<synopsis>
  <code >OZ_Term OZ_mkTuple(OZ_Term label, int width, ...)</code>
<item>Returns a new tuple with label <code /label/ and width <code /width/.
    All subtrees from 1 to <code /width/ must be given as arguments
    after <code /width/.  Example:
<code display >
OZ_mkTuple(OZ_atom("f"),2,OZ_atom("a"),OZ_int(1))
</code>
  creates the tuple <<f(a 1)>>.

<entry><<OZ_mkTupleC>>
<synopsis>
  <code >OZ_Term OZ_mkTupleC(char *label, int width, ...)</code>
<item>Analogously to <code /OZ_mkTuple/, but expects the label as a C
    string.

<entry><<OZ_getArg>>
<synopsis>
  <code >OZ_Term OZ_getArg(OZ_Term tuple, int pos)</code>
<item>Returns the subtree of tuple <code /tuple/ at <code /pos/.  The tuple
    arguments are numbered starting from 0.

<entry><<OZ_nil>>
<synopsis>
  <code >OZ_Term OZ_nil()</code> <item>Returns the atom <<nil>>.

<entry><<OZ_cons>>
<synopsis>
  <code >OZ_Term OZ_cons(OZ_Term head, OZ_Term tail)</code>
<item>Returns a binary tuple with label <<'|'>>, where the first field is
    <code /head/, the second is <code /tail/.

<entry><<OZ_head>>
<synopsis>
  <code >OZ_Term OZ_head(OZ_Term t)</code>
<item>Returns the first field of <code /t/. <code /t/ must be a tuple with
    label <<'|'>>  and width 2.

<entry><<OZ_tail>>
<synopsis>
  <code >OZ_Term OZ_tail(OZ_Term t)</code>
<item>Returns the second field of <code /t/. <code /t/ must be a tuple with
    label <<'|'>>  and width 2.

<entry><<OZ_length>>
<synopsis>
  <code >int OZ_length(OZ_Term t)</code>
<item>Compute the length of the &Oz; list <code /t/.  This function returns
    <code /-1/, if <code /t/ is not determined and <code /-2/, if <code /t/ is
    not a list.

<entry><<OZ_toList>>
<synopsis>
  <code >OZ_Term OZ_toList(int n, OZ_Term *t)</code>
<item>Creates an &Oz; list out of an array <code /t/ of <code /n/
    values.

<entry><<OZ_pair>>
<synopsis>
  <code >OZ_Term OZ_pair(int n)</code>
<item>Returns a mixfix pair, with <code /n/ subtrees.  The subtrees are not
    initialized and must be defined with <code /OZ_putArg/.

<entry><<OZ_pair2>>
<synopsis>
  <code >OZ_Term OZ_pair2(OZ_Term left, OZ_Term right)</code>
<item>Returns a mixfix pair, where the first field is <code /left/ and the
    second is <code /right/.

<entry><<OZ_pairA>>
<synopsis>
  <code >OZ_Term OZ_pairA(char *left, OZ_Term right)</code>
<item>Macro for creating a mixfix pair of an atom and a value. It is
    defined as:
<code display >
OZ_pair2(OZ_atom(left),right)
</code>

<entry><<OZ_pairAA>>
<synopsis>
  <code >OZ_Term OZ_pairAA(char *left, char *right)</code>
<item>Macro for creating a mixfix pair of two atoms. It is defined as:
<code display >
OZ_pair2(OZ_atom(left),OZ_atom(right))
</code>

<entry><<OZ_pairAI>>
<synopsis>
  <code >OZ_Term OZ_pairAI(char *left, int right)</code>
<item>Macro for creating a mixfix pair of an atom and an integer.  It is
    defined as:
<code display >
OZ_pair2(OZ_atom(left),OZ_int(right))
</code>

<entry><<OZ_pairAS>>
<synopsis>
  <code >OZ_Term OZ_pairAS(char *left, char *right)</code>
<item>Macro for creating a mixfix pair of an atom and a string. It is
    defined as:
<code display >
OZ_pair2(OZ_atom(left),OZ_string(right))
</code>

<entry><<OZ_subtree>>
<synopsis>
  <code >OZ_Term OZ_subtree(OZ_Term record, OZ_Term feature)</code>
<item>Returns the subtree of record <code /record/ at <code /feature/.}

<entry><<OZ_record>>
<synopsis>
  <code >OZ_Term OZ_record(OZ_Term label, OZ_Term arity)</code>
<item>Creates a new record with label <code /label/ and list of features
    <code /arity/.  Note that the values of all subtrees are still
    undefined.  Hence a call to this function should be immediately
    followed by calls to <code /OZ_putSubtree/.

<entry><<OZ_recordInit>>
<synopsis>
  <code >OZ_Term OZ_recordInit(OZ_Term lbl,OZ_Term propList)</code>
<item>Creates a new record with label <code /lbl/. The property list
      <code /propList/ contains all features and their subtree as mixfixed
    pairs.

<entry><<OZ_putSubtree>>
<synopsis>
  <code >void OZ_putSubtree(OZ_Term record, OZ_Term feature,
    OZ_Term newTerm)</code>
<item>Destructively sets the subtree of record <code /record/ at
      <code /feature/ to <code /newTerm/. Should be only used for records
    created with <code /OZ_record/ or <code /OZ_recordInit/.

<entry><<OZ_arityList>>
<synopsis>
<code >OZ_Term OZ_arityList(OZ_Term record)</code>
<item>Returns the arity of record <code /record/ as an &Oz; list.

<entry><<OZ_adjoinAt>>
<synopsis>
<code >OZ_Term OZ_adjoinAt
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(OZ_Term rec,OZ_Term fea,OZ_Term val)</code>
<item>Returns a new record by adjoining subtree <code /val/ at feature <code /fea/ to record <code /rec/.

<entry><<OZ_newVariable>>
<synopsis>
  <code >OZ_Term OZ_newVariable()</code>
<item>Creates a new variable.

<entry><<OZ_newName>>
<synopsis>
  <code >OZ_Term OZ_newName()</code>
<item>Creates a new name.}

<entry><<OZ_newChunk>>
<synopsis>
  <code >OZ_Term OZ_newChunk(OZ_Term record)</code>
<item>Creates a new chunk.

<entry><<OZ_newCell>>
<synopsis>
  <code >OZ_Term OZ_newCell(OZ_Term t)</code>
<item>Creates a new cell with initial content <code /t/.

<entry><<OZ_newPort>>
<synopsis>
  <code >OZ_Term OZ_newPort(OZ_Term s)</code>
<item>Creates a new port with stream <code /s/.

<entry><<OZ_send>>
<synopsis>
  <code >void OZ_send(OZ_Term p, OZ_Term t)</code>
<item>Sends value <code /t/ to port <code /p/.

<entry><<OZ_onToplevel>>
<synopsis>
  <code >int OZ_onToplevel()</code>
<item>Returns nonzero iff called on toplevel, &ie; not within a local
    space.
</list></section>
<section><title/Exceptions/
<p>
<list>

<entry><<OZ_raise>>
<synopsis>
  <code >OZ_Return OZ_raise(OZ_Term t)</code>
<item>Raises exception <code /t/.

<entry><<OZ_raiseC>>
<synopsis>
  <code >OZ_Return OZ_raiseC(char *label,int arity,...)</code>
<item>Raises an exception. The exception is created from the argument
    list just the way it is done by <code /OZ_mkTupleC/.

<entry><<OZ_typeError>>
<synopsis>
  <code >OZ_Return OZ_typeError(int pos, char *type)</code>
<item>Raises an exception indicating that the argument at position
      <code /pos/ is of incorrect type. <code /type/ should be a string
    describing the expected type.
</list></section>
<section><title/Unification/
<p>
<list>

<entry><<OZ_unify>>
<synopsis>
  <code >OZ_Return OZ_unify(OZ_Term t1, OZ_Term t2)</code>
<item>Unify <code /t1/ and <code /t2/. Return <code /OZ_ENTAILED/ on success
    and <code /OZ_FAILED/ on failure.

<entry><<OZ_unifyInt>>
<synopsis>
  <code >OZ_Return OZ_unifyInt(OZ_Term t1, int i)</code>
<item>This is an abbreviation for <code /OZ_unify(t1, OZ_int(i))/

<entry><<OZ_unifyFloat>>
<synopsis>
  <code >OZ_Return OZ_unifyFloat(OZ_Term t1, float f)</code>
<item>This is an abbreviation for <code /OZ_unify(t1, OZ_float(f))/

<entry><<OZ_unifyAtom>>
<synopsis>
  <code >OZ_Return OZ_unifyAtom(OZ_Term t1, char *s)</code>
<item>This is an abbreviation for <code /OZ_unify(t1, OZ_atom(s))/

<entry><<OZ_eq>>
<synopsis>
  <code >OZ_Return OZ_eq(OZ_Term t1, OZ_Term t2)</code>
<item>Return non-null, if <code /t1/ and <code /t2/ reference the same Oz
  object in the store.

<entry><<OZ_eqAtom>>
<synopsis>
  <code >OZ_Return OZ_eqAtom(OZ_Term t1, char *s)</code>
<item>This is an abbreviation for <code /OZ_eq(t1, OZ_atom(s))/

<entry><<OZ_eqInt>>
<synopsis>
  <code >OZ_Return OZ_eqInt(OZ_Term t1, int i)</code>
<item>This is an abbreviation for <code /OZ_eq(t1, OZ_int(i))/

<entry><<OZ_eqFloat>>
<synopsis>
  <code >OZ_Return OZ_eqFloat(OZ_Term t1, double d)</code>
<item>This is an abbreviation for <code /OZ_eq(t1, OZ_float(d))/


</list></section>



<section id=section.threads><title/Threads/
<p>
<list>

<entry><<OZ_makeRunnableThread>>
<synopsis>
  <code >void OZ_makeRunnableThread(OZ_CFun fun, OZ_Term *args, int n) </code>
<item>Creates a thread with one task to execute the function <code /fun/
    with arguments <code /args[0],&ellipsis;,args[n-1]/.

<entry><<OZ_getLowPrio>>
<entry><<OZ_getMediumPrio>>
<entry><<OZ_getHighPrio>>
<synopsis>

<code>
int OZ_getLowPrio()
int OZ_getMediumPrio()
int OZ_getHighPrio()
</code>
<item>Return the appropriate thread priorities.
</list></section>
<section><title/Printing/
<p>
<list>

<entry><<OZ_warning>>
<synopsis>
  <code >void OZ_warning(char *format ...)</code>
<item>Prints a warning message to the standard error device. Can be used
    like <code /printf(3)/.

</list></section>

<section><title/Miscellaneous/
<p>

<list>

<entry><<OZ_false>>
<synopsis>
  <code >OZ_term OZ_false()</code>
<item>Returns the &Oz; name for the boolean value <code /false/.

<entry><<OZ_true>>
<synopsis>
  <code >OZ_term OZ_true()</code>
<item>Returns the &Oz; name for the boolean value <code /true/.

<entry><<OZ_unit>>
<synopsis>
  <code >OZ_term OZ_unit()</code>
<item>Returns the &Oz; name for <code /unit/.

<entry><<OZ_smallIntMin>>
<synopsis>
  <code >int OZ_smallIntMin()</code>
<item>Returns the minimal small integer.

<entry><<OZ_smallIntMax>>
<synopsis>
  <code >int OZ_smallIntMax()</code>
<item>Returns the maximal small integer.

<entry><<OZ_featureCmp>>
<synopsis>
  <code >int OZ_featureCmp(OZ_Term t1, OZ_Term t2)</code>
<item>Compares the features <code /t1/ and <code /t2/.  Returns zero if they are
    equal, -1 if <code /t1/ is less than <code /t2/ and 1 if <code /t2/ is
    less than <code /t1/.

<entry><<OZ_suspendOn>>
<synopsis>
  <code >OZ_suspendOn(OZ_Term v)</code>
<item>Suspends the executing thread on <code /v/. <code /v/ must be a
    variable. When <code /v/ gets bound then the thread gets woken by
    first reexecuting the enclosing C function from the beginning.

<entry><<OZ_suspendOn2>>
<entry><<OZ_suspendOn3>>
<index class=module/OZsuspendOn2/
<index class=module/OZsuspendOn3/
<synopsis>
  <code >
OZ_suspendOn2(OZ_Term v1, OZ_Term v2)
OZ_suspendOn3(OZ_Term v1, OZ_Term v2, OZ_Term v3)
</code>
<item>Like <code /OZ_suspendOn/ , but suspends the executing thread
    disjunctively on the argument variables.
</list>
</section>

<section><title/Garbage collection/
<p>
Care must be taken about proper interaction with the &Oz; garbage
collector: it does not notice if you store an <code /OZ_Term/ into a
global C variable. Therefore it will free the space on the heap
occupied by this term, which leads to memory faults. &Oz; provides functions
to explicitly inform the garbage collector about external references
to the heap.
<list>
<entry><<OZ_protect>>
<synopsis>
  <code >int OZ_protect(OZ_Term *tp)</code>
<item>During garbage collection the term <code /tp/ points to is visited
    and may be moved. Therefore <code /tp/ must be a <em/pointer/ to a
    term.  The location where <code /tp/ points to is modified by the
    garbage collector.
<entry><<OZ_unprotect>>
<synopsis>
  <code >int OZ_unprotect(OZ_Term *tp)</code>
<item>This is the inverse function to <code /OZ_protect/ informing the
    garbage collector that the reference to the heap is no longer
    used.
</list>
</section>


<section><title>Concurrent Input and Output</title>
<p>
Reading from or writing to a file descriptor may block, since buffers
my be empty or resp. full. Thus calling <code /read/ or <code /write/
might block the whole Oz process. We therefor provide abstractions that
allow concurrent access to file descriptors from within the C level.

<p>
We first declare an abstact type <code /OZ_IOHandler/ which is a
function expecting an integer and an arbitry pointer:
<p>
<code>
   typedef int OZ_IOHandler(int, void *);
</code>
<p>

The user can than use the following abstractions:
<list>
<entry><<OZ_registerReadHandler>>
<synopsis>
  <code >void OZ_registerReadHandler(int fd,OZ_IOHandler fun,void *args)</code>
<item>Registers <code /fun/ as a read handler for file descriptor
<code /fd/. Any previously registered function will be
overridden. When input gets available on <code /fd/ then <code
/fun(fd,args)/ will be called by the Oz scheduler. The usage of <code
/args/ provides a way to pass arbitrary arguments to <code /fun/.

<entry><<OZ_unregisterRead>>
<synopsis>
  <code >void OZ_unregisterRead(int fd)</code>
<item>Unregisters a previously registered read handler for file
descriptor <code /fd/.

<entry><<OZ_registerWriteHandler>>
<synopsis>
  <code >void OZ_registerWriteHandler(int fd,OZ_IOHandler fun,void *args)</code>
<item>Analogously to <code /OZ_registerReadHandler/ for writing. <code
/fun/ is called as soon as the output buffer for <code /fd/ gets empty.

<entry><<OZ_unregisterWrite>>
<synopsis>
  <code >void OZ_unregisterWrite(int fd)</code>
<item>Unregisters a previously registered write handler for file
descriptor <code /fd/.
</list>

</section>

</chapter>

<Chapter id="chapter.extension">
<Title/The Extension class/

<P>The C++ class <<OZ_Extension>> allows for an easy integration of new
 built-in data types into the Oz VM.

<p>To add a new data type a native module must be implemented which contains
(1) a subclass of <<OZ_Extension>> (see below) and (2) built-in procedures
implementing the operation on the new type.

<p>If you want to implement situated extension, i.e. data types which
are situated in computation spaces and need to be copied you should
subclass <<OZ_SituatedExtension>> with has the same interface as
<<OZ_Extension>>.

<p>In <Ptr to="section.extension.reference"> you find the reference
documentation and in <Ptr to="section.extension.example"> an example.

<Section id="section.extension.reference">
  <Title/Reference/

    <SubSection id="section.extension.reference.class">
<Title/The class <<Oz_Extension>>/

 <p>The class <<OZ_Extension>> implements the methods defined below.
 The methods <<getIdV>> and <<gcV>> which are marked as
 required are pure virtual and have to be implemented in every
 subclass.

<LIST CLASS=EXPORTS>

  <ENTRY><<virtual int getIdV()>> // required

  <ITEM>Allows to discriminate the different kinds of extensions. It
      should return a unique number.  Unique numbers can be obtained
      using <<int OZ_getUniqueId()>>.

      <p>Ids can be statically assigned by extending the enumeration
      <<OZ_Registered_Extension_Id>>.

  <ENTRY><<virtual Extension* gcV()>> // required

<ITEM>Invoked when copying is request. Needed for garbage collection and
      in the case of <<OZ_SituatedExtension>> also for copying.

  <ENTRY><<virtual void gcRecurseV()>> // default: do nothing
<ITEM>Invoked on the copy obtained from <<gcV>>.  The VM has marked the data
such that recursive updates of fields, e.g. running <<OZ_gcHeapNode>>,
do not run into cycles.

  <ENTRY><<virtual OZ_Term printV(int depth = 10)>> // default: return
  <<extension>>
  <ITEM>printV should return a virtual string and is used for
  printing, e.g. System.show.

  <ENTRY><<virtual OZ_Term printLongV(int depth = 10, int offset = 0)>> // default: call printV
  <ITEM>This may help debugging, but is currently not used.

  <ENTRY><<virtual OZ_Term typeV()>> // default: return <<extension>>
  <ITEM>typeV should return an atom describing the type of the
      extension. This value is also return in Value.status and
      Value.type.  It should not conflict with the built-in types.

<ENTRY><<virtual OZ_Term inspectV()>> // default: call typeV
<ITEM>Not used. Idea: hook for debugging tools to get information.

  <ENTRY><<virtual Bool isChunkV()>> // default: return true
<ITEM>Define this to return false is the extension in not a subtype of
      chunk.

  <ENTRY><<virtual OZ_Term getFeatureV(OZ_Term fea)>> // default: return 0
<ITEM>If the operator <<.>> (dot) is applied to an extension this function is
      called. If <<getFeatureV>> returns 0 an exception is raised that the
      feature is not available.

  <ENTRY><<virtual OZ_Return eqV(OZ_Term t)>> // default: return false
<ITEM>This function is called during unification and equality test
      (==), if both values are extensions. Implement it if you need
      structural equality. Note that in this case <<isChunkV>> should
      return false.

  <ENTRY><<virtual Bool marshalV(MsgBuffer *bs)>>  // default: return false
<ITEM>      This is the hook to serialization.  It returns true if the
      extension is serializable and writes it external representation
      into the message buffer (see <<oz_registerExtension>> below).

  <ENTRY><<OZ_Boolean isLocal()>>
<ITEM>Returns true if a situated extensions is local to the current space.

</LIST>

<SubSection id="section.extension.reference.functions">
<Title/Functions/

<p>
<LIST CLASS=EXPORTS>
<ENTRY><<Bool OZ_isExtension(OZ_Term t)>>
<ITEM>Tests if the OZ_Term is an extension (<<t>> must be dereferenced
first).

<ENTRY><<Extension *OZ_getExtension(OZ_Term t)>>
<ITEM>Unbox the OZ_Term into an extension
     (<<t>> must be dereferenced).

<ENTRY><<OZ_Term oz_extension(Extension *e)>>
<ITEM>Box the Extension into an OZ_Term.

<ENTRY><<typedef OZ_Term (*oz_unmarshalProcType)(MsgBuffer*)
void oz_registerExtension(int id, oz_unmarshalProcType f)>>
<ITEM>Registers an unmarshal procedure for the extension with the given
id.

<ENTRY><<int OZ_getUniqueId()>>
<ITEM>Returns a new unique number usable as the id of an extension.

</LIST>


<Section id="section.extension.example">
  <Title/Example/

<p>The following is a snippet from the implementation of bit arrays
(bitarray.cc).

<Code.extern display TO="bitarray.cc">


</chapter>

  <Back>
</Book>
