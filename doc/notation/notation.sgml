<!--
  - Author:
  -   Leif Kornstaedt <kornstae@ps.uni-sb.de>
  -
  - Copyright:
  -   Leif Kornstaedt, 1998
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation of Oz 3:
  -   http://www.mozart-oz.org
  -
  - See the file "LICENSE" or
  -   http://www.mozart-oz.org/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<!DOCTYPE Book SYSTEM "ozdoc.dtd" [

<!-- Extension to the DTD -->
<!ENTITY % input.local.2 SYSTEM "notation.extra">
<!ENTITY % p.mix.local "|Rewrite">
<!ENTITY % proglang.values.local "|fundamental">
<!ENTITY % author.class "author|author.extern|comic">
<!ENTITY % picture.element "picture|picture.extern|picture.choice">
<!ELEMENT comic - O (%picture.element;)>

<!-- Abbreviations -->
<!ENTITY amp "&">
<!ENTITY lt "<">
<!ENTITY gt ">">

<!-- Processing Instructions -->
<!ENTITY ellipsis PI "ellipsis">
<!ENTITY nbsp PI "nbsp">
<!ENTITY eg PI "eg">
<!ENTITY ie PI "ie">
<!ENTITY emdash PI "emdash">
<!ENTITY slash PI "slash">

]>

<Book proglang=oz>
  <Front>
    <Meta name="html.split" value="chapter.intro">
    <Meta name="html.split" value="chapter.lexical">
    <Meta name="html.split" value="chapter.context-free">
    <Meta name="html.split" value="chapter.core">
    <Meta name="html.split" value="chapter.translation">
    <Meta name="html.split" value="section.translation.base">
    <Meta name="html.split" value="section.translation.constraints">
    <Meta name="html.split" value="section.translation.classes">
    <Meta name="html.split" value="section.translation.functors">
    <Meta name="html.split.toc" value="">
    <Meta name="html.split.bib" value="">

    <Meta name="proglang.mode" arg1="fundamental" arg2="fundamental-mode">

    <Meta name=ozversion value="3.0">
    <Meta name=status value=draft>
    <Title/The Oz Notation/
    <Author.Extern to="author.db" key="Martin.Henz">
    <Author.Extern to="author.db" key="Leif.Kornstaedt">
    <Comic>
      <Picture.Choice>
        <Picture.Extern to="notation.gif" type=gif>
      </Picture.Choice>
    <Abstract>
      Oz is a concurrent language providing for functional, object-oriented,
      and constraint programming.  This document defines how Oz program text
      is transformed into an Oz Core program.  Oz Core is a sublanguage of Oz
      designed to minimize syntactic complexity.  Oz Core serves as the base
      for the definition of the semantics of Oz.
    <P>
      Technically, Oz Core allows to use several programming paradigms,
      including functional, constraint and object-oriented programming.
      Being a purely relational language, however, Oz Core does not
      provide easy notational access to programming methods from these
      paradigms, making it hard to fully exploit the capacities of the
      language.
    <P>
      It is such ergonomic considerations that lead to the development
      of the Oz Notation, where syntactic extensions provide convenient
      constructs for functional and object-oriented programming.
      The semantics of these extensions is defined in this document
      by their stepwise translation to Oz Core.
    </Abstract>
  <Body>
    <Chapter id="chapter.intro">
      <Title/Introduction/
      <P>
        This report defines how Oz program text, which is a sequence
        of characters, is transformed into an Oz Core program.  This
        transformation is performed in three steps.
        <List enum>
          <Entry/Lexical Syntax/
          <Item>
            First, a given program text is transformed into a sequence of
            words.  Each word represents a sequence of tokens.  We call this
            process <Def/tokenizing/.
          <Entry/Context-free Syntax/
          <Item>
            The resulting sequence of tokens is transformed into a parse tree.
            We call this process <Def/parsing/, and the resulting parse tree
            <Def/program/.
          <Entry/Core Programs/
          <Item>
            The program is translated to a Core program, eliminating a number
            of abbreviations and nesting.
        </List>
      <P>
        At each step, errors may occur.  A text represents an Oz program if
        it can be tokenized and parsed into a program which can be translated
        without error into a Core program.
      <Para class=apropos><Title/Meta Notation/
        In a document like this one, it is helpful to make use of notational
        conventions in order to provide for concise and precise descriptions.
      <Section>
        <Title/Fonts/
        <P>
          We make use of fonts to distinguish the different kinds of symbols
          occurring in this document:
          <Table>
            <TR>
              <TH/Meaning/
              <TH/Examples/
            <TR>
              <TD/terminal or nonterminal symbol/
              <TD/?={variable}, ?={statement}/
            <TR>
              <TD/keyword/
              <TD/<<local>>, <<skip>>/
          </Table>
      <Section>
        <Title/Regular Expressions and Context-Free Grammars/
        <P>
          Regular expressions and context free grammars describe
          sets of words.  We use the following notation to describe
          one such set in terms of others (in increasing order of
          precedence):
          <Table>
            <TR>
              <TH/Notation/
              <TH/Meaning/
            <TR>
              <TD/<Math/\epsilon//
              <TD/singleton containing the empty word/
            <TR>
              <TD/(<Math/w/)/
              <TD/grouping of regular expressions/
            <TR>
              <TD/[&nbsp;<Math/w/&nbsp;]/
              <TD/union of <Math/\epsilon/ with the set of words&nbsp;<Math/w//
            <TR>
              <TD/{&nbsp;<Math/w/&nbsp;}/
              <TD/set of words containing all concatenations of zero or
                more elements of&nbsp;<Math/w//
            <TR>
              <TD/{&nbsp;<Math/w/&nbsp;}+/
              <TD/set of words containing all concatenations of one or
                more elements of&nbsp;<Math/w//
            <TR>
              <TD/<Math/w_1/&nbsp;<Math/w_2//
              <TD/set of words containing all concatenations of an element
                of&nbsp;<Math/w_1/ with an element of&nbsp;<Math/w_2//
            <TR>
              <TD/<Math/w_1/&nbsp;|&nbsp;<Math/w_2//
              <TD/union of <Math/w_1/ and&nbsp;<Math/w_2//
            <TR>
              <TD/<Math/w_1/&nbsp;-&nbsp;<Math/w_2//
              <TD/difference of <Math/w_1/ and&nbsp;<Math/w_2//
          </Table>
    <Chapter id="chapter.lexical" proglang=fundamental>
      <Title/Lexical Syntax/
      <P>
        A <Def/program text/ is a sequence of <Def/characters/ represented by
        integers following ISO&nbsp;8859-1&nbsp;<Ptr to="ISO_8859_1">, also
        called <Q/Latin&nbsp;1/.  In this section, we describe how such a
        sequence is split into a sequence of <Def/words/.  Each word
        represents zero or more <Def/tokens/ such that the result is a
        sequence of tokens.  We call this process <Def/tokenization/.
        In this section, we give regular expressions for the different kinds
        of words and describe the resulting tokens.
      <Para class=apropos><Title/Resolving Ambiguities/
        The splitting of a sequence of characters using these regular
        expressions is not unique.  We use the usual left to right longest
        match tokenization obtaining either error or a unique sequence of
        tokens from a given sequence of characters.  Longest match means
        that if two or more prefixes of the remaining character string are
        matched by (possibly different) regular expressions, we select the
        match that accepts the longest prefix.  Note that the regular
        expressions are designed such that left to right longest match
        tokenization is unique.
      <Para class=apropos><Title/Lexical Errors/
        When no regular expression matches a prefix of the remaining
        character string, we speak of a <Def/lexical error/.  Such an
        input sequence does not represent a valid Oz program.
      <Section>
        <Title/Character Class Definitions/
        <P>
          This section defines character classes used in the regular
          expressions given in the remainder of the chapter.  Note that
          these regular expressions do not&emdash;on their own&emdash;define
          any splitting of the input into words.
        <P>
          We use NUL to denote the ISO character with code&nbsp;0 and
          ?={any character} to denote the set of all ISO characters.
          <Grammar.Rule/?={upper-case letter}
            <Grammar.Alt/<<A>> | &ellipsis; | <<Z>> |
              <<À>> | &ellipsis; | <<Ö>> | <<Ø>> | &ellipsis; | <<Þ>>//
          <Grammar.Rule/?={lower-case letter}
            <Grammar.Alt/<<a>> | &ellipsis; | <<z>> |
              <<ß>> | &ellipsis; | <<ö>> | <<ø>> | &ellipsis; | <<ÿ>>//
          <Grammar.Rule/?={digit}
            <Grammar.Alt/<<0>> | &ellipsis; | <<9>>//
          <Grammar.Rule/?={non-zero digit}
            <Grammar.Alt/<<1>> | &ellipsis; | <<9>>//
          <Grammar.Rule/?={alphanumerical}
            <Grammar.Alt/?={upper-case letter} | ?={lower-case letter} |
              ?={digit} | <<_>>//
          <Grammar.Rule/?={atom char}
            <Grammar.Alt/?={any character} - ( <<'>> | <<\>> | NUL )//
          <Grammar.Rule/?={string char}
            <Grammar.Alt/?={any character} - ( <<">> | <<\>> | NUL )//
          <Grammar.Rule/?={variable char}
            <Grammar.Alt/?={any character} - ( <<`>> | <<\>> | NUL )//
          <Grammar.Rule/?={escape character}
            <Grammar.Alt/<<a>> | <<b>> | <<f>> | <<n>> | <<r>> | <<t>> | <<v>>
              | <<\>> | <<'>> | <<">> | <<`>> | <<&>>//
          <Grammar.Rule/?={octal digit}
            <Grammar.Alt/<<0>> | &ellipsis; | <<7>>//
          <Grammar.Rule/?={hex digit}
            <Grammar.Alt/<<0>> | &ellipsis; | <<9>> |
              <<A>> | &ellipsis; | <<F>> | <<a>> | &ellipsis; | <<f>>//
          <Grammar.Rule/?={binary digit}
            <Grammar.Alt/<<0>> | <<1>>//
        <Para class=apropos><Title/Pseudo-Characters/
          In the classes of words ?={variable}, ?={atom}, ?={string}, and
          ?={character} we use pseudo-characters, which represent single
          characters in different notations.
          <Grammar.Rule/?={pseudo char}
            <Grammar.Alt/<<\>> ?={octal digit} ?={octal digit} ?={octal digit}/
            <Grammar.Alt/<<\>> ( <<x>> | <<X>> ) ?={hex digit} ?={hex digit}/
            <Grammar.Alt/<<\>> ?={escape character}//
          Pseudo-characters allow to enter any ISO&nbsp;8859-1 character
          using octal or hexadecimal notation.  Octal notation is restricted
          to numbers less than 256.  The NUL character (ISO code&nbsp;0) is
          forbidden.  The pseudo-characters <<\a>>&nbsp;(=&nbsp;<<\007>>),
          <<\b>>&nbsp;(=&nbsp;<<\010>>), <<\f>>&nbsp;(=&nbsp;<<\014>>),
          <<\n>>&nbsp;(=&nbsp;<<\012>>), <<\r>>&nbsp;(=&nbsp;<<\015>>),
          <<\t>>&nbsp;(=&nbsp;<<\011>>), <<\v>>&nbsp;(=&nbsp;<<\013>>)
          denote special purpose characters, and
          <<\\>>&nbsp;(=&nbsp;<<\134>>), <<\'>>&nbsp;(=&nbsp;<<\047>>),
          <<\">>&nbsp;(=&nbsp;<<\042>>), <<\`>>&nbsp;(=&nbsp;<<\140>>),
          <<\&>>&nbsp;(=&nbsp;<<\046>>) denote their second component
          character.
      <Section>
        <Title/Spaces and Comments/
        <P>
          Spaces are tab (code&nbsp;9), newline (code&nbsp;10), vertical
          tab (code&nbsp;11), form feed (code&nbsp;12), carriage return
          (code&nbsp;13), and blank (code&nbsp;32).
        <P>
          A comment is:
          <List>
            <Item>
              a sequence of characters from&nbsp;<<%>> until the end of
              the line or file,
            <Item>
              a sequence of characters within and including the comment
              brackets <</*>> and&nbsp;<<*/>>, in which <</*>> and&nbsp;<<*/>>
              are properly nested, and
            <Item>
              the character&nbsp<<?>>.
          </List>
        <P>
          Spaces and comments produce no tokens.  This means that they are
          ignored, except that they separate words form each other.
      <Section>
        <Title/Keywords/
        <P>
          <Grammar.Rule proglang=oz>?={keyword}
            <Grammar.Alt><<andthen>> | <<at>> | <<attr>> | <<case>> |
              <<catch>> | <<choice>></Grammar.Alt>
            <Grammar.Alt><<class>> | <<cond>> | <<declare>> |
              <<define>> | <<dis>></Grammar.Alt>
            <Grammar.Alt><<div>> | <<else>> | <<elsecase>> | <<elseif>> |
              <<end>></Grammar.Alt>
            <Grammar.Alt><<export>> | <<fail>> | <<false>> | <<feat>> |
              <<finally>> | <<from>></Grammar.Alt>
            <Grammar.Alt><<fun>> | <<functor>> | <<if>> | <<import>> |
              <<in>> | <<local>></Grammar.Alt>
            <Grammar.Alt><<lock>> | <<meth>> | <<mod>> | <<not>> |
              <<of>> | <<or>> | <<orelse>></Grammar.Alt>
            <Grammar.Alt><<prepare>> | <<proc>> | <<prop>> |
              <<raise>> | <<require>></Grammar.Alt>
            <Grammar.Alt><<self>> | <<skip>> | <<then>> | <<thread>> |
              <<true>> | <<try>></Grammar.Alt>
            <Grammar.Alt><<unit>> | <<(>> | <<)>> | <<[>> |
              <<]>> | <<{>> | <<}>></Grammar.Alt>
            <Grammar.Alt><<|>> | <<#>> | <<:>> | <<...>> | <<=>> |
              <<.>> | <<:=>> | <<^>> | <<[]>> | <<$>></Grammar.Alt>
            <Grammar.Alt><<!>> | <<_>> | <<~>> | <<+>> | <<->> | <<*>> |
              <</>> | <<@>> | <<&lt;->></Grammar.Alt>
            <Grammar.Alt><<,>> | <<!!>> | <<&lt;=>> | <<==>> | <<\=>> |
              <<&lt;>> | <<=&lt;>> | <<&gt;>></Grammar.Alt>
            <Grammar.Alt><<&gt;=>> | <<=:>> | <<\=:>> | <<&lt;:>> |
              <<=&lt;:>> | <<&gt;:>> | <<&gt;=:>> | <<::>> |
              <<:::>></Grammar.Alt>
          Each keyword represents itself as token.
      <Section>
        <Title/Variables/
        <P>
          <Grammar.Rule/?={variable}
            <Grammar.Alt/?={upper-case letter} { ?={alphanumerical} }/
            <Grammar.Alt/<<`>> { ?={variable char} | ?={pseudo char} } <<`>>//
          A word of the form ?={variable} represents a variable token
          of the form <Math/\lfloor/<<variable>>, ?{n}+<Math/\rfloor/,
          where ?{n}+ is the sequence of characters that make up the
          word, including the possibly surrounding <<`>>&nbsp;characters.
        <P>
          For example, the word <Code proglang=oz/Xs/ represents the token
          <Math/\lfloor/<<variable>>, 88 115<Math/\rfloor/
          and the word <Code proglang=oz/`\n`/ represents the token
          <Math/\lfloor/<<variable>>, 96 10 96<Math/\rfloor/.
          Variable tokens are denoted by the terminal symbol ?={variable}
          in the following context-free grammars.
      <Section>
        <Title/Atoms/
        <P>
          <Grammar.Rule/?={atom}
            <Grammar.Alt/?={lower-case letter} { ?={alphanumerical} } -
              ?={keyword}/
            <Grammar.Alt/<<'>> { ?={atom char} | ?={pseudo char} } <<'>>//
          A word of the form ?={atom} represents an atom token of the form
          <Math/\lfloor/<<atom>>, ?{n}*<Math/\rfloor/, where ?{n}* is the
          sequence of characters that make up the word, excluding the possibly
          surrounding <<'>>&nbsp;characters.
        <P>
          For example, the word <Code proglang=oz/atom/ represents the token
          <Math/\lfloor/<<atom>>, 97 116 111 109<Math/\rfloor/
          and the word <Code proglang=oz/'\n'/ represents the token
          <Math/\lfloor/<<atom>>, 10<Math/\rfloor/.
          Atom tokens are denoted by the terminal symbol ?={atom}
          in the following context-free grammars.
      <Section>
        <Title/Labels/
        <P>
          <Grammar.Rule/?={label}
            <Grammar.Alt/( ?={variable} | ?={atom} | <<true>> | <<false>> |
              <<unit>> ) <<(>>//
          A word of the form ?={label} represents a sequence of two tokens.
          The first is a label token of the form
          <Math/\lfloor/<<variablelabel>>, ?{n}+<Math/\rfloor/,
          <Math/\lfloor/<<atomlabel>>, ?{n}*<Math/\rfloor/
          (similar to the corresponding tokens for words of the form
          ?={variable} and ?={atom}), <<truelabel>>, <<falselabel>>, or
          <<unitlabel>>.  The second token is the keyword&nbsp;<<(>>.
          For example, the word <Code proglang=oz/Xs(/ represents the tokens
          <Math/\lfloor/<<variablelabel>>, 88 115<Math/\rfloor/ and&nbsp;<<(>>,
          and the word <Code proglang=oz/true(/ represents the tokens
          <<truelabel>> and&nbsp;<<(>>.  The label tokens are denoted
          by the terminal symbols ?={variable label}, ?={atom label},
          ?={unit label}, ?={true label}, and ?={false label} in the
          following context-free grammars.
      <Section>
        <Title/Integers/
        <P>
          <Grammar.Rule/?={int}
            <Grammar.Alt/[ <<~>> ] ( <<0>> | ?={non-zero digit} { ?={digit} } )
              <Grammar.Note/decimal representation//
            <Grammar.Alt/[ <<~>> ] <<0>> { ?={octal digit} }+
              <Grammar.Note/octal representation//
            <Grammar.Alt/[ <<~>> ] <<0>> ( <<x>> | <<X>> ) { ?={hex digit} }+
              <Grammar.Note/hexadecimal representation//
            <Grammar.Alt/[ <<~>> ] <<0>> ( <<b>> | <<B>> )
              { ?={binary digit} }+
              <Grammar.Note/binary representation///
          A word of the form ?={int} represents an integer token of the form
          <Math/\lfloor/<<int>>, ?{n}<Math/\rfloor/, where ?{n} represents the
          integer for which ?={int} is the representation.
        <P>
          For example, the word <Code proglang=oz/~159/ represents the token
          <Math/\lfloor/<<int>>, -159<Math/\rfloor/,
          the word <Code proglang=oz/077/ the token
          <Math/\lfloor/<<int>>, 63<Math/\rfloor/,
          the word <Code proglang=oz/0xFF/ the token
          <Math/\lfloor/<<int>>, 255<Math/\rfloor/,
          and the word <Code proglang=oz/~0b11111/ the token
          <Math/\lfloor/<<int>>, -31<Math/\rfloor/.
          Integer tokens are denoted by the terminal symbol ?={int}
          in the following context-free grammars.
      <Section>
        <Title/Floats/
        <P>
          <Grammar.Rule/?={float}
            <Grammar.Alt/[ <<~>> ] { ?={digit} }+ <<.>> { ?={digit} }
              [ ( <<e>> | <<E>> ) [ <<~>> ] { ?={digit} }+ ]//
          A word of the form ?={float} represents a float token of the form
          <Math/\lfloor/<<float>>, ?{f}<Math/\rfloor/,
          where ?{f} represents the floating point number for which the word
          is the decimal representation.  The letters <<e>> and <<E>> both
          indicate the exponent to&nbsp;10.
        <P>
          For example, the word <Code proglang=oz/~1.5e2/ represents the token
          <Math/\lfloor/<<float>>, -150.0<Math/\rfloor/.
          Float tokens are denoted by the terminal symbol ?={float}
          in the following context-free grammars.
        <P>
          The syntax of floats is implementation-dependent in that
          syntactically correct floats may be approximated by the
          compiler if they cannot be represented by the implementation.
      <Section>
        <Title/Strings/
        <P>
          <Grammar.Rule/?={string}
            <Grammar.Alt/<<">> { ?={string char} | ?={pseudo char} } <<">>//
          The word <Code proglang=oz/""/ represents the token
          <Math/\lfloor/<<atom>>, 110 105 108<Math/\rfloor/, which denotes
          the empty list <Code proglang=oz/nil/.  A word of the form
          <<">><Math/c_1/ &ellipsis; <Math/c_m/<<">>, where <Math/m \geq 1/,
          represents a sequence of <Math/m + 2/ tokens of the form
          <<[>>&nbsp;<Math/n_1/ &ellipsis; <Math/n_m/&nbsp;<<]>>,
          where the <Math/n_i/ represent integer tokens according to
          the ISO&nbsp;8859-1 code of&nbsp;<Math/c_i/.
        <P>
          For example, the word <Code proglang=oz/"ab"/ represents the
          sequence of tokens <<[>>&nbsp;<Math/\lfloor/<<int>>, 97<Math/\rfloor/
          <Math/\lfloor/<<int>>, 98<Math/\rfloor/&nbsp;<<]>>.
      <Section>
        <Title/Characters/
        <P>
          <Grammar.Rule/?={character}
            <Grammar.Alt/<<&amp;>> ( ?={any character} - ( <<\>> | NUL ) |
              ?={pseudo char} )//
          A word of the form ?={character} represents the integer token
          according to the code of the character denoted by the word without
          the <<&amp;>>&nbsp;prefix.
        <P>
          For example, the word <Code proglang=oz/&amp;a/ represents the token
          <Math/\lfloor/<<int>>, 97<Math/\rfloor/.
    <Chapter id="chapter.context-free">
      <Title/Context-Free Syntax/
      <P>
        In this section, we give a context-free grammar for a superset of
        Oz programs.  Any sequence of tokens that is not a member of the
        language described by this grammar, starting from the ?={statement}
        nonterminal, is considered erroneous.
      <P>
        Implementations may accept a larger language, &eg;, something more
        than only a statement at top-level, or treat lexical syntax that
        has no assigned meaning in the report as compiler directives.
      <Section>
        <Title/The Base Language/
        <Para class=apropos><Title/Statements/
          <Grammar.Rule/?={statement}
            <Grammar.Alt/?={statement} ?={statement}/
            <Grammar.Alt/<<local>> ?={in statement} <<end>>/
            <Grammar.Alt/<Q class=terminal/<<(>>/ ?={in statement}
              <Q class=terminal/<<)>>//
            <Grammar.Alt/<<proc>> { ?={atom} } <Q class=terminal/<<{>>/
              ?={expression} { ?={pattern} } <Q class=terminal/<<}>>//
            <Grammar.Alt type=space/?={in phrase}/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<fun>> { ?={atom} } <Q class=terminal/<<{>>/
              ?={expression} { ?={pattern} } <Q class=terminal/<<}>>//
            <Grammar.Alt type=space/?={in expression}/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<Q class=terminal/<<{>>/ ?={expression}
              { ?={expression} } <Q class=terminal/<<}>>//
            <Grammar.Alt/<<if>> ?={expression} <<then>> ?={in statement}/
            <Grammar.Alt type=space/[ ?={else statement} ]/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<case>> ?={expression}
              <<of>> ?={case statement clause}/
            <Grammar.Alt type=space/{ <<[]>> ?={case statement clause} }/
            <Grammar.Alt type=space/[ ?={else statement} ]/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<lock>> ?={expression} <<then>> ?={in statement}
              <<end>>/
            <Grammar.Alt/<<thread>> ?={in statement} <<end>>/
            <Grammar.Alt/<<try>> ?={in statement}/
            <Grammar.Alt type=space/[ <<catch>> ?={case statement clause}
              { <Q class=terminal/<<[]>>/ ?={case statement clause} } ]/
            <Grammar.Alt type=space/[ <<finally>> ?={in statement} ]/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<raise>> ?={in expression} <<end>>/
            <Grammar.Alt/?={expression} <Q class=terminal/<<=>>/
              ?={expression}/
            <Grammar.Alt/?={expression} <Q class=terminal/<<:=>>/
              ?={expression}/
            <Grammar.Alt/?={expression} <Q class=terminal/<<.>>/ ?={expression} <Q class=terminal/<<:=>>/
              ?={expression}/
            <Grammar.Alt/<<skip>>//
        <Para class=apropos><Title/Expressions/
          <!--** explain the nesting marker -->
          <Grammar.Rule/?={expression}
            <Grammar.Alt/<<local>> ?={in expression} <<end>>/
            <Grammar.Alt/<Q class=terminal/<<(>>/ ?={in expression}
              <Q class=terminal/<<)>>//
            <Grammar.Alt/<<proc>> { ?={atom} } <Q class=terminal/<<{>>/
              <Q class=terminal/<<$>>/ { ?={pattern} }
              <Q class=terminal/<<}>>//
            <Grammar.Alt type=space/?={in phrase}/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<fun>> { ?={atom} } <Q class=terminal/<<{>>/
              <Q class=terminal/<<$>>/ { ?={pattern} }
              <Q class=terminal/<<}>>//
            <Grammar.Alt type=space/?={in expression}/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<Q class=terminal/<<{>>/ ?={expression}
              { ?={expression} } <Q class=terminal/<<}>>//
            <Grammar.Alt/<<if>> ?={expression} <<then>> ?={in expression}/
            <Grammar.Alt type=space/?={else expression}/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<case>> ?={expression}
              <<of>> ?={case expression clause}/
            <Grammar.Alt type=space/{ <<[]>> ?={case expression clause} }/
            <Grammar.Alt type=space/[ ?={else expression} ]/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<lock>> ?={expression} <<then>> ?={in expression}
              <<end>>/
            <Grammar.Alt/<<thread>> ?={in expression} <<end>>/
            <Grammar.Alt/<<try>> ?={in expression}/
            <Grammar.Alt type=space/[ <<catch>> ?={case expression clause}
              { <Q class=terminal/<<[]>>/ ?={case expression clause} } ]/
            <Grammar.Alt type=space/[ <<finally>> ?={in statement} ]/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<raise>> ?={in expression} <<end>>/
            <Grammar.Alt/?={expression} <Q class=terminal/<<=>>/
              ?={expression}/
            <Grammar.Alt/?={expression} <<orelse>> ?={expression}/
            <Grammar.Alt/?={expression} <<andthen>> ?={expression}/
            <Grammar.Alt/?={monop} ?={expression}/
            <Grammar.Alt/?={expression} ?={binop} ?={expression}/
            <Grammar.Alt/?={expression} <Q class=terminal/<<:=>>/ ?={expression}/
            <Grammar.Alt/?={expression} <Q class=terminal/<<.>>/ ?={expression} <Q class=terminal/<<:=>>/
              ?={expression}/
            <Grammar.Alt/?={possibly escaped variable}/
            <Grammar.Alt/<Q class=terminal/<<_>>//
            <Grammar.Alt/?={atom} | ?={int} | ?={float}/
            <Grammar.Alt/<<unit>> | <<true>> | <<false>>/
            <!--** describe what omitted features mean -->
            <Grammar.Alt/?={label} <Q class=terminal/<<(>>/
              { ?={subtree} } [ <Q class=terminal/<<...>>/ ]
              <Q class=terminal/<<)>>//
            <Grammar.Alt/<Q class=terminal/<<[>>/ { ?={expression} }+
              <Q class=terminal/<<]>>//
            <Grammar.Alt/?={expression}
              <Q class=terminal/<<|>>/ ?={expression}/
            <Grammar.Alt/?={expression}
              { <Q class=terminal/<<#>>/ ?={expression} }+/
            <Grammar.Alt/<Q class=terminal/<<$>>///
          <Grammar.Rule/?={label}
            <Grammar.Alt/?={variable label} | ?={atom label}/
            <Grammar.Alt/?={unit label} | ?={true label} | ?={false label}//
          <Grammar.Rule/?={feature}
            <Grammar.Alt/?={variable} | ?={atom} | ?={int}/
            <Grammar.Alt/<<unit>> | <<true>> | <<false>>//
          <Grammar.Rule/?={subtree}
            <Grammar.Alt/[ ?={feature} <Q class=terminal/<<:>>/ ]
              ?={expression}//
        <Para class=apropos><Title/Precedence/
          Note that in both ?={statement}s and ?={expression}s there is potential ambiguity
          between ?={expression} <Q class=terminal/<<:=>>/ ?={expression} and
          ?={expression} <Q class=terminal/<<.>>/ ?={expression} <Q class=terminal/<<:=>>/
          ?={expression}. In fact <Q class=terminal/<<. :=>>/ is a ternary operator and has
          precedence.  Parenthesis must be used for
          the alternate parse, that is, (?={expression}<Q class=terminal/<<.>>/ ?={expression}) <Q class=terminal/<<:=>>/
          ?={expression}.
         <P>
          The assignment operators <Q class=terminal/<<. :=>>/ and <Q class=terminal/<<:=>>/,
          when used in expression position,
          perform an atomic exchange, the result of the operation
          being the previous value of the stateful entity assigned to.
        <Para class=apropos><Title/Operators/
          Expressions with operators need additional disambiguating
          rules introduced in&nbsp;<Ptr to="section.context-free.operators">.
          <Grammar.Rule/?={monop}
            <Grammar.Alt/<Q class=terminal/<<~>>/ |
              <Q class=terminal/<<!!>>/ | <Q class=terminal/<<@>>//
          <Grammar.Rule>?={binop}
            <Grammar.Alt/<Q class=terminal/<<.>>/ |
              <Q class=terminal/<<^>>//
            <Grammar.Alt/<Q class=terminal/<<==>>/ |
              <Q class=terminal/<<\=>>/ | <Q class=terminal/<<&lt;>>/ |
              <Q class=terminal/<<&lt;=>>/ | <Q class=terminal/<<&gt;>>/ |
              <Q class=terminal/<<&gt;=>>//
            <Grammar.Alt><Q class=terminal/<<+>>/ |
              <Q class=terminal/<<->>/ | <Q class=terminal/<<*>>/ |
              <Q class=terminal><</>></Q> | <<div>> | <<mod>></Grammar.Alt>
        <Para class=apropos><Title/Declarations/
          A ?={declaration part} is a sequence of variables and statements.
          Singleton variables serve only for explicit declaration and are
          otherwise ignored.  Variables within statements are implicitly
          declared if they occur at a <Def/pattern position/.  A prefixed
          escape&nbsp;(<<!>>) prevents implicit declaration.
          <Grammar.Rule/?={declaration part}
            <Grammar.Alt/?={variable}/
            <Grammar.Alt/?={statement}/
            <Grammar.Alt/?={declaration part} ?={declaration part}//
          <Grammar.Rule/?={in statement}
            <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}//
          <Grammar.Rule/?={in expression}
            <Grammar.Alt/[ ?={declaration part} <<in>> ] [ ?={statement} ]
              ?={expression}//
          <Grammar.Rule/?={possibly escaped variable}
            <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable}//
        <P>
          As procedure body either a statement or an expression may be
          possible, depending on whether the procedure's formal parameter
          patterns contain a nesting marker&nbsp;(<<$>>) or not.
          <Grammar.Rule/?={in phrase}
            <Grammar.Alt/?={in statement}/
            <Grammar.Alt/?={in expression}//
        <Para class=apropos><Title/Patterns/
          Pattern matching is performed as a top-down left-to-right
          sequence of tests.  Record patterns test a value's constructor;
          constant patterns and escaped variable patterns test for equality
          with the given value; nonlinearities (variables occurring multiply
          in one pattern) test for equality of the corresponding subtrees.
          Equation patterns and non-escaped variables introduce variable
          bindings.
          <Grammar.Rule/?={pattern}
            <Grammar.Alt/?={label} <Q class=terminal/<<(>>/
              { ?={subpattern} } [ <Q class=terminal/<<...>>/ ]
              <Q class=terminal/<<)>>//
            <Grammar.Alt/<Q class=terminal/<<[>>/ { ?={pattern} }+
              <Q class=terminal/<<]>>//
            <Grammar.Alt/?={pattern} <Q class=terminal/<<|>>/ ?={pattern}/
            <Grammar.Alt/?={pattern} { <Q class=terminal/<<#>>/ ?={pattern} }+/
            <Grammar.Alt/?={atom} | ?={int} | ?={float}/
            <Grammar.Alt/<<unit>> | <<true>> | <<false>>/
            <Grammar.Alt/?={possibly escaped variable}/
            <Grammar.Alt/<Q class=terminal/<<_>>//
            <Grammar.Alt/?={pattern} <Q class=terminal/<<=>>/ ?={pattern}/
            <Grammar.Alt/<Q class=terminal/<<(>>/ ?={pattern}
              <Q class=terminal/<<)>>///
          <Grammar.Rule/?={subpattern}
            <Grammar.Alt/[ ?={feature} <Q class=terminal/<<:>>/ ] ?={pattern}//
        <P>
          Following the pattern an additional side condition can be given.
          It is only evaluated if the pattern matched, in the environment
          extended by the bindings introduced by the pattern.  The variables
          introduced in the optional ?={declaration part} are also visible
          in the clause's body.
          <Grammar.Rule/?={case statement clause}
            <Grammar.Alt/?={pattern}
              [ <<andthen>> [ ?={declaration part} <<in>> ] ?={expression} ]/
            <Grammar.Alt type=space/<<then>> ?={in statement}//
          <Grammar.Rule/?={case expression clause}
            <Grammar.Alt/?={pattern}
              [ <<andthen>> [ ?={declaration part} <<in>> ] ?={expression} ]/
            <Grammar.Alt type=space/<<then>> ?={in expression}//
        <Para class=apropos><Title/Else Clauses/
          If the <<else>> part to an <<if>> statement is omitted, it is taken
          to be <<else skip>>.  The <<else>> part to an <<if>> expression is
          mandatory.
        <P>
          If the <<else>> part to a <<case>> statement or expression is
          omitted and no pattern matches, an error exception is raised.
          <Grammar.Rule/?={else statement}
            <Grammar.Alt/<<elseif>> ?={expression} <<then>> ?={in statement}/
            <Grammar.Alt type=space/[ ?={else statement} ]/
            <Grammar.Alt/<<elsecase>> ?={expression} <<of>>
              ?={case statement clause}/
            <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
              ?={case statement clause} }/
            <Grammar.Alt type=space/[ ?={else statement} ]/
            <Grammar.Alt/<<else>> ?={in statement}//
          <Grammar.Rule/?={else expression}
            <Grammar.Alt/<<elseif>> ?={expression} <<then>> ?={in expression}/
            <Grammar.Alt type=space/?={else expression}/
            <Grammar.Alt/<<elsecase>> ?={expression} <<of>>
              ?={case expression clause}/
            <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
              ?={case expression clause} }/
            <Grammar.Alt type=space/[ ?={else expression} ]/
            <Grammar.Alt/<<else>> ?={in expression}//
      <Section>
        <Title/Constraint Extensions and Combinators/
        <Para class=apropos><Title/Statements/
          <Grammar.Rule/?={statement}
            <Grammar.Alt type=add/?={fd compare}/
            <Grammar.Alt/?={fd in}/
            <Grammar.Alt/<<fail>>/
            <Grammar.Alt/<<not>> ?={in statement} <<end>>/
            <Grammar.Alt/<<cond>> ?={cond statement clause}/
            <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
              ?={cond statement clause} }/
            <Grammar.Alt type=space/[ <<else>> ?={in statement} ]/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<or>> ?={dis statement clause}
              { <Q class=terminal/<<[]>>/
              ?={dis statement clause} }+ <<end>>/
            <Grammar.Alt/<<dis>> ?={dis statement clause}
              { <Q class=terminal/<<[]>>/
              ?={dis statement clause} }+ <<end>>/
            <Grammar.Alt/<<choice>> ?={in statement}
              { <Q class=terminal/<<[]>>/ ?={in statement} } <<end>>//
          <Grammar.Rule/?={cond statement clause}
            <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}
              <<then>> ?={in statement}//
          <Grammar.Rule/?={dis statement clause}
            <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}
              [ <<then>> ?={in statement} ]//
        <Para class=apropos><Title/Expressions/
          <Grammar.Rule/?={expression}
            <Grammar.Alt type=add/?={fd compare}/
            <Grammar.Alt/?={fd in}/
            <Grammar.Alt/<<fail>>/
            <Grammar.Alt/<<cond>> ?={cond expression clause}/
            <Grammar.Alt type=space/{ <Q class=terminal/<<[]>>/
              ?={cond expression clause} }/
            <Grammar.Alt type=space/[ <<else>> ?={in expression} ]/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<or>> ?={cond expression clause}
              { <Q class=terminal/<<[]>>/
              ?={cond expression clause} }+ <<end>>/
            <Grammar.Alt/<<dis>> ?={cond expression clause}
              { <Q class=terminal/<<[]>>/
              ?={cond expression clause} }+ <<end>>/
            <Grammar.Alt/<<choice>> ?={in expression}
              { <Q class=terminal/<<[]>>/
              ?={in expression} } <<end>>//
          <Grammar.Rule/?={cond expression clause}
            <Grammar.Alt/[ ?={declaration part} <<in>> ] ?={statement}
              <<then>> ?={in expression}//
          <Grammar.Rule/?={fd compare}
            <Grammar.Alt/?={expression} (
              <Q class=terminal/<<=:>>/ |
              <Q class=terminal/<<\=:>>/ |
              <Q class=terminal/<<&lt;:>>/ |
              <Q class=terminal/<<=&lt;:>>/ |
              <Q class=terminal/<<&gt;:>>/ |
              <Q class=terminal/<<&gt;=:>>/ ) ?={expression}//
          <Grammar.Rule/?={fd in}
            <Grammar.Alt/?={expression} (
              <Q class=terminal/<<::>>/ |
              <Q class=terminal/<<:::>>/ ) ?={expression}//
      <Section>
        <Title/Class Extensions/
        <Para class=apropos><Title/Class Definitions/
          <Grammar.Rule/?={statement}
            <Grammar.Alt type=add/<<class>> ?={expression}/
            <Grammar.Alt type=space/{ ?={class descriptor} }/
            <Grammar.Alt type=space/{ ?={method} }/
            <Grammar.Alt type=space/<<end>>//
          <Grammar.Rule/?={expression}
            <Grammar.Alt type=add/<<class>> [ <Q class=terminal/<<$>>/ ]/
            <Grammar.Alt type=space/{ ?={class descriptor} }/
            <Grammar.Alt type=space/{ ?={method} }/
            <Grammar.Alt type=space/<<end>>/
          <Grammar.Rule/?={class descriptor}
            <Grammar.Alt/<<from>> { ?={expression} }+/
            <Grammar.Alt/<<prop>> { ?={expression} }+/
            <Grammar.Alt/<<attr>> { ?={attr or feat} }+/
            <Grammar.Alt/<<feat>> { ?={attr or feat} }+//
        <P>
          Non-escaped variables are implicitly introduced with class scope,
          bound to new names.  This allows to model private components.
          <Grammar.Rule/?={attr or feat}
            <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable} |
              ?={atom} | ?={int}/
            <Grammar.Alt/<<unit>> | <<true>> | <<false>>//
        <Para class=apropos><Title/Methods/
          The first-class message used to invoke a method can be referenced
          by appending <<=>>&nbsp;?={variable} to the method head.  This
          message does not contain defaulted arguments (see below) if they
          have not been explicitly given.
          <Grammar.Rule/?={method}
            <Grammar.Alt/<<meth>> ?={method head}
              [ <Q class=terminal/<<=>>/ ?={variable} ]/
            <Grammar.Alt type=space/?={in phrase}/
            <Grammar.Alt type=space/<<end>>//
        <P>
          If dots are given, any additional features are allowed in the
          first-class message; else, extraneous features cause an error
          exception to be raised.
          <Grammar.Rule/?={method head}
            <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable} | ?={atom}/
            <Grammar.Alt/<<unit>> | <<true>> | <<false>>/
            <Grammar.Alt/?={method head label} <Q class=terminal/<<(>>/
              { ?={method formal} } [ <Q class=terminal/<<...>>/ ]
              <Q class=terminal/<<)>>//
          <Grammar.Rule/?={method head label}
            <Grammar.Alt/[ <Q class=terminal/<<!>>/ ] ?={variable label} |
              ?={atom label}/
            <Grammar.Alt/?={unit label} | ?={true label} | ?={false label}//
        <P>
          A default <<&lt;=>> after a formal argument allows for the
          corresponding actual argument to be omitted from a first-class
          method.  In this case, the default expression will be evaluated
          (inside the method) and the formal argument variable bound to the
          result.
          <Grammar.Rule/?={method formal}
            <Grammar.Alt/[ ?={feature} <Q class=terminal/<<:>>/ ]
              ( ?={variable} | <Q class=terminal/<<_>>/ |
              <Q class=terminal/<<$>>/ )/
            <Grammar.Alt type=space/[ <Q class=terminal/<<&lt;=>>/
              ?={expression} ]//
        <Para class=apropos><Title/Operations/
          To the following operators, <<self>> is an implicit operand.
          Their use is syntactically restricted to the body of method
          definitions.
          <Grammar.Rule/?={statement}
            <Grammar.Alt type=add/<<lock>> ?={in statement} <<end>>/
            <Grammar.Alt/?={expression} <Q class=terminal/<<&lt;->>/
              ?={expression}/
            <Grammar.Alt/?={expression} <Q class=terminal/<<,>>/
              ?={expression}//
          The assignment operator <Q class=terminal/<<&lt;->>/, when used in expression position,
          performs an atomic exchange, the result of the operation
          being the previous value of the attribute assigned to.
          <Grammar.Rule/?={expression}
            <Grammar.Alt type=add/<<lock>> ?={in expression} <<end>>/
            <Grammar.Alt/?={expression} <Q class=terminal/<<&lt;->>/
              ?={expression}/
            <Grammar.Alt/?={expression} <Q class=terminal/<<,>>/
              ?={expression}/
            <Grammar.Alt/<<self>>//
      <Section>
        <Title/Functor Extensions/
        <P>
          A functor definition creates a chunk with (at least) features
          <<'import'>> and <<'export'>> describing its interface and a
          feature <<apply>> containing a procedure mapping an import record
          to an export module.
          <Grammar.Rule/?={statement}
            <Grammar.Alt type=add/<<functor>> ?={expression}
              { ?={functor descriptor} } <<end>>//
          <Grammar.Rule/?={expression}
            <Grammar.Alt type=add/<<functor>> [ <Q class=terminal/<<$>>/ ]
              { ?={functor descriptor} } <<end>>//
        <Para class=apropos><Title/Import Specification/
          The import specification names values (usually modules) to be made
          available to the body.  They represent formal arguments to the
          body abstraction.  The additional <<at>> clause allows to specify
          where the actual argument is to come from.  This must be an atom
          (interpreted as a relative URL) so that a functor creating the
          referenced module may be located at compile time.
          <Grammar.Rule/?={functor descriptor}
            <Grammar.Alt/<<import>> { ?={import clause} }+//
          <Grammar.Rule/?={import clause}
            <Grammar.Alt/?={variable} [ <<at>> ?={atom} ]/
            <Grammar.Alt/?={variable label} ?={import features}
              [ <<at>> ?={atom} ]//
          If the expected structure of an imported value is partially
          specified, occurrences of the module name are restricted
          to a single syntactic context:  the first operand in
          applications of the dot operator, where the second operand
          is one of the features mentioned in the import specification.
          <Grammar.Rule/?={import features}
            <Grammar.Alt/<Q class=terminal/<<(>>/
              { ?={module feature} ?={import alias} }+
              <Q class=terminal/<<)>>///
          <Grammar.Rule/?={module feature}
            <Grammar.Alt/?={atom} | ?={int}//
          An <Def/import alias/ introduces a variable bound to one of the
          imported module's subtrees.
          <Grammar.Rule/?={import alias}
            <Grammar.Alt/[ <Q class=terminal/<<:>>/ ?={variable} ]//
        <Para class=apropos><Title/Functor Body/
          The body of the functor is a statement (usually a sequence of
          definitions that compute the exported values).  This statement
          is a pattern position.  Note the difference between this
          abbreviated declaration and the ?={in statement} rule:
          The ?={statement} following the <<in>> keyword is optional,
          not the ?={declaration part} preceding it.
          <Grammar.Rule/?={functor descriptor}
            <Grammar.Alt type=add/<<define>> ?={declaration part}
              [ <<in>> ?={statement} ]//
        <Para class=apropos><Title/Export Specification/
          The export specification specifies the structure the
          modules created by applications of this functor will have.
          <Grammar.Rule/?={functor descriptor}
            <Grammar.Alt type=add/<<export>>
              { [ ?={module feature} <Q class=terminal/<<:>>/ ]
              ?={variable} }+//
          The value of the variables mentioned in the export declaration
          are made available under the given features.  If a feature is
          omitted, then it is computed from the corresponding variable's
          print name by changing its initial capital letter into a
          lower-case letter (unless it's a backquote variable, in which
          case the print name is taken as-is).
        <P>
          All variables introduced in the import and the body are visible
          in the export declaration.
        <Para class=apropos><Title/Computed Functors/
          A functor that contains one of the following additional functor
          descriptors is called a <Def/computed functor/.  The <<require>>
          and <<prepare>> clauses correspond to the <<import>> and <<define>>
          clauses respectively, only they are executed upon functor definition
          instead of functor application.  The variables introduced by these
          clauses are visible in the <<define>> and <<export>> clauses.
          <Grammar.Rule/?={functor descriptor}
            <Grammar.Alt type=add/<<require>> { ?={import clause} }+/
            <Grammar.Alt/<<prepare>> ?={declaration part}
              [ <<in>> ?={statement} ]//
      <Section id="section.context-free.operators">
        <Title/Operator Associativity and Precedence/
        <P>
          The grammar given above is ambiguous.  Some ambiguities do not
          affect the semantics (such as associativity of ?={statement}s and
          ?={declaration part}s).  Those that do are resolved according to
          the following table stating the associativity of operators in
          increasing order of precedence:
          <Table>
            <TR>
              <TH/Operators/
              <TH/Associativity/
            <TR>
              <TD/<<X=Y>>/
              <TD/right/
            <TR>
              <TD/<<X&lt;-Y>>&nbsp;&nbsp;&nbsp;<<X:=Y>>&nbsp;&nbsp;&nbsp;<<X.Y:=Z>>/
              <TD/right/
            <TR>
              <TD/<<X orelse Y>>/
              <TD/right/
            <TR>
              <TD/<<X andthen Y>>/
              <TD/right/
            <TR>
              <TD/<<X==Y>>&nbsp;&nbsp;&nbsp;<<X\=Y>>&nbsp;&nbsp;&nbsp;
                  <<X&lt;Y>>&nbsp;&nbsp;&nbsp;<<X=&lt;Y>>&nbsp;&nbsp;&nbsp;
                  <<X&gt;Y>>&nbsp;&nbsp;&nbsp;<<X&gt;=Y>>/
            <TR>
              <TD/<<X=:Y>>&nbsp;&nbsp;&nbsp;<<X\=:Y>>&nbsp;&nbsp;&nbsp;
                  <<X&lt;:Y>>&nbsp;&nbsp;&nbsp;<<X=&lt;:Y>>&nbsp;&nbsp;&nbsp;
                  <<X&gt;:Y>>&nbsp;&nbsp;&nbsp;<<X&gt;=:Y>>/
              <TD/none/
            <TR>
              <TD/<<X::Y>>&nbsp;&nbsp;&nbsp;<<X:::Y>>/
              <TD/none/
            <TR>
              <TD/<<X|Y>>/
              <TD/right/
            <TR>
              <TD/<<X#Y>>/
              <TD/mixfix/
            <TR>
              <TD/<<X+Y>>&nbsp;&nbsp;&nbsp;<<X-Y>>/
              <TD/left/
            <TR>
              <TD><<X*Y>>&nbsp;&nbsp;&nbsp;<<X/Y>>&nbsp;&nbsp;&nbsp;
                  <<X div Y>>&nbsp;&nbsp;&nbsp;<<X mod Y>></TD>
              <TD/left/
            <TR>
              <TD/<<X,Y>>/
              <TD/right/
            <TR>
              <TD/<<~X>>/
              <TD/prefix/
            <TR>
              <TD/<<X.Y>>&nbsp;&nbsp;&nbsp;<<X^Y>>/
              <TD/left/
            <TR>
              <TD/<<@X>>&nbsp;&nbsp;&nbsp;<<!!X>>/
              <TD/prefix/
          </Table>
          <Q/Having higher precedence/ means <Q/binding tighter/; &eg;,
          the expression <<c#X.g = Y>> is parsed as <<(c#(X.g)) = Y>>.
        <P>
          Attempts to exploit associativity of non-associative operators
          (without using parentheses to make the intention clear),
          as in <<X &lt; Y &lt; Z>>, are considered erroneous.
    <Chapter id="chapter.core">
      <Title/Core Programs/
      <P>
        In this section, we give a context-free grammar for Core Oz programs.
      <Section>
        <Title/The Base Language/
        <Para class=apropos><Title/Statements/
          <Grammar.Rule/?={statement}
            <Grammar.Alt/?={statement} ?={statement}/
            <Grammar.Alt/<<local>> { ?={variable} }+
              <<in>> ?={statement} <<end>>/
            <Grammar.Alt/<<proc>> { ?={atom} } <Q class=terminal/<<{>>/
              ?={variable} { ?={variable} } <Q class=terminal/<<}>>//
            <Grammar.Alt type=space/?={statement}/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<Q class=terminal/<<{>>/ ?={variable}
              { ?={variable} } <Q class=terminal/<<}>>//
            <Grammar.Alt/<<lock>> ?={variable} <<then>> ?={statement}
              <<end>>/
            <Grammar.Alt/<<thread>> ?={statement} <<end>>/
            <Grammar.Alt/<<try>> ?={statement}/
            <Grammar.Alt type=space/<<catch>> ?={variable} <<then>>
              ?={statement}/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/
              <Q class=terminal/<<@>>/ ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<:=>>/
              ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/
              ?={variable} <Q class=terminal/<<:=>>/
              ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<.>>/ ?={variable} <Q class=terminal/<<:=>>/
              ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/
              ?={variable} <Q class=terminal/<<.>>/ ?={variable} <Q class=terminal/<<:=>>/
              ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/
              ?={expression}/
            <Grammar.Alt/<<skip>>//
        <Para class=apropos><Title/Expressions/
          <Grammar.Rule/?={expression}
            <Grammar.Alt/?={variable}/
            <Grammar.Alt/?={atom} | ?={int} | ?={float}/
            <Grammar.Alt/?={label} <Q class=terminal/<<(>>/
              { ?={feature} <Q class=terminal/<<:>>/ ?={expression} }
              [ <Q class=terminal/<<...>>/ ]
              <Q class=terminal/<<)>>///
          <Grammar.Rule/?={label}
            <Grammar.Alt/?={variable label} | ?={atom label}//
          <Grammar.Rule/?={feature}
            <Grammar.Alt/?={variable} | ?={atom} | ?={int}//
      <Section>
        <Title/Class Extensions/
        <P>
          <Grammar.Rule/?={statement}
            <Grammar.Alt type=add/<<class>> ?={variable}/
            <Grammar.Alt type=space/[ <<from>> { ?={variable} }+ ]/
            <Grammar.Alt type=space/[ <<prop>> { ?={variable} }+ ]/
            <Grammar.Alt type=space/[ <<attr>> { <Q class=terminal/<<!>>/
              ?={variable} [ <Q class=terminal/<<:>>/ ?={variable} ] }+ ]/
            <Grammar.Alt type=space/[ <<feat>> { <Q class=terminal/<<!>>/
              ?={variable} [ <Q class=terminal/<<:>>/ ?={variable} ] }+ ]/
            <Grammar.Alt type=space/{ ?={method} }/
            <Grammar.Alt type=space/<<end>>/
            <Grammar.Alt/<<lock>> ?={statement} <<end>>/
            <Grammar.Alt/?={variable} <Q class=terminal/<<&lt;->>/
              ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/
              ?={variable} <Q class=terminal/<<&lt;->>/ ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<,>>/ ?={variable}/
            <Grammar.Alt/?={variable} <Q class=terminal/<<=>>/ <<self>>//
        <Para class=apropos><Title/Methods/
          <Grammar.Rule/?={method}
            <Grammar.Alt/<<meth>> <Q class=terminal/<<!>>/ ?={variable}
              <Q class=terminal/<<(>>/ <Q class=terminal/<<...>>/
              <Q class=terminal/<<)>>/ <Q class=terminal/<<=>>/ ?={variable}/
            <Grammar.Alt type=space/?={statement}/
            <Grammar.Alt type=space/<<end>>//
    <Chapter id="chapter.translation">
      <Title/Translation of Oz Programs to Oz Core Programs/
      <P>
        Oz programs are translated to Oz core programs by repeatedly
        applying the rules given in this chapter to subtrees of the
        parse tree, replacing the subtree with the result of the rule.
        A rule consists of the following:
        <List>
          <Entry/A set of nonterminals./
          <Item>
            The rule is only applicable to subtrees generated by a
            rule of one of these nonterminals.
          <Entry/A left-hand side./
          <Item>
            The rule is only applicable if the subtree's structure matches
            the left-hand side pattern.  Additionally, variables are
            introduced.  Some parts may be left out (replaced by an
            ellipsis) if they reappear unmodified in the output.
          <Entry/A right-hand side./
          <Item>
            When the rule is applied to a subtree, the latter is replaced
            by the subtree specified by the right-hand side.  This may
            contain variables written as ?_{X}, ?_{Y}, or&nbsp;?_{Z} not
            appearing in the left-hand side:  These variables are supposed
            to be fresh such that no capturing can occur.
          <Entry/Optionally, a side condition./
          <Item>
            The rule is only applicable if the side-condition is satisfied.
        </List>
      <Para class=apropos><Title/Meta Variables/
        Inside rewrite rules, we use meta variables for terminals and phrases
        generated by nonterminals as shown in the following table:
        <Table>
          <TR>
            <TH/Meta Variables/
            <TH/Corresponding Terminals and Nonterminals/
          <TR>
            <TD/?{x}, ?{x1}, &ellipsis;, ?{xn}/
            <TD/?={variable}/
          <TR>
            <TD/?{D}/
            <TD/?={declaration part}/
          <TR>
            <TD/?{S}/
            <TD/?={statement}/
          <TR>
            <TD/?{E}, ?{E1}, &ellipsis;, ?{Ek}, ?{En}/
            <TD/?={expression}/
          <TR>
            <TD/?{SE}/
            <TD/?={statement} or ?={expression}/
          <TR>
            <TD/?{P}, ?{P1}, &ellipsis;, ?{Pk}, ?{Pn}/
            <TD/?={pattern}/
          <TR>
            <TD/?{EP}, ?{EP1}, &ellipsis;, ?{EPn}/
            <TD/?={expression} or ?={pattern}/
          <TR>
            <TD/?{C}, ?{C1}, &ellipsis;, ?{Cn}/
            <TD/?={case statement clause} or ?={case expression clause}/
          <TR>
            <TD/?{L}, ?{L1}, &ellipsis;, ?{Ln}/
            <TD/?={cond statement clause} or ?={cond expression clause}
              or ?={dis statement clause}/
          <TR>
            <TD/?{l}/
            <TD/?={label}/
          <TR>
            <TD/?{f1}, &ellipsis;, ?{fn}/
            <TD/?={feature}/
          <TR>
            <TD/?{s1}, &ellipsis;, ?{sn}/
            <TD/?={subtree} or ?={subpattern}/
        </Table>
      <Para class=apropos><Title/Core Variables/
        The result of the transformation may have references to so-called
        <Def/Core variables/.  We indicate this by writing them in backquotes;
        they are not bound lexically, but are looked up in static environment.
        Examples are <<`List.toRecord`>> and <<`RaiseDebugCheck`>>.  If the
        print name of a Core variable contains a dot, then it is supposed to
        be looked up (without the backquotes) in the Base Environment (see
        <Ptr.Extern to="ozdoc:base">).
        <!--** what if it does not contain a dot -->
      <Para class=apropos><Title/Errors/
        When no rule is applicable and the program is not an Oz Core program,
        we speak of a <Def/syntax error/.  Such a program is not a valid
        Oz program.
      <Section id="section.translation.base">
        <Title/The Base Language/
        <SubSection class=unnumbered>
          <Title/Declarations/
          <P>
            <Rewrite>?={in statement}
              <Rewrite.From/<<?{D} in ?{S}>>/
              <Rewrite.To/<<local ?{D} in ?{S} end>>/
            </Rewrite>
            <Rewrite>?={in expression}
              <Rewrite.From/<<?{D} in >>[ ?{S} ]<< ?{E}>>/
              <Rewrite.To/<<local ?{D} in >>[ ?{S} ]<< ?{E} end>>/
            </Rewrite>
          <P>
            The following rule makes implicit declarations explicit,
            &ie;, declarations only name variables between <<local>> and
            <<in>>.  We need an auxiliary definition:  The function ?{PV}
            returns the set of <Def/pattern variables/ of a statement
            (or expression).  Furthermore, we call a position&nbsp;?{p}
            in a given statement&nbsp;?{S} a <Def/pattern position/ iff the
            following holds:  If the subterm at position&nbsp;?{p} of&nbsp;?{S}
            is replaced by a fresh variable&nbsp;?_{X}, then ?_{X} <Math/\in/
            ?{PV}(?{S}[?_{X}/?{p}]).
            <Table>
              <TR>
                <TH/?{D}/
                <TH/?{PV}(?{D})/
              <TR>
                <TD/<<?{D1} ?{D2}>>/
                <TD/?{PV}(?{D1}) <Math/\cup/ ?{PV}(?{D2})/
              <TR>
                <TD/<<?{x}>>/
                <TD/{?{x}}/
              <TR>
                <TD/<<(?{S})>>/
                <TD/?{PV}(?{S})/
              <TR>
                <TD/<<(?{D} in ?{S})>>/
                <TD/?{PV}(?{S}) - ?{PV}(?{D})/
              <TR>
                <TD/<<local ?{D} in ?{S} end>>/
                <TD/?{PV}(?{S}) - ?{PV}(?{D})/
              <TR>
                <TD/<<proc &ellipsis; {?{E} &ellipsis;} &ellipsis; end>>/
                <TD/?{PV}(?{E})/
              <TR>
                <TD/<<fun &ellipsis; {?{E} &ellipsis;} &ellipsis; end>>/
                <TD/?{PV}(?{E})/
              <TR>
                <TD/<<class ?{E} &ellipsis; end>>/
                <TD/?{PV}(?{E})/
              <TR>
                <TD/<<functor ?{E} &ellipsis; end>>/
                <TD/?{PV}(?{E})/
              <TR>
                <TD/<<?{E} = &ellipsis;>>/
                <TD/?{PV}(?{E})/
              <TR>
                <TD/otherwise/
                <TD/<Math/\emptyset//
            </Table>
            <Table>
              <TR>
                <TH/?{E}/
                <TH/?{PV}(?{E})/
              <TR>
                <TD/<<?{x}>>/
                <TD/{?{x}}/
              <TR>
                <TD/<<(?{E})>>/
                <TD/?{PV}(?{E})/
              <TR>
                <TD/<<(?{D} in >>[ ?{S} ]<< ?{E})>>/
                <TD/(?{PV}(?{S}) <Math/\cup/ ?{PV}(?{E})) - ?{PV}(?{D})/
              <TR>
                <TD/<<local ?{D} in >>[ ?{S} ]<< ?{E} end>>/
                <TD/(?{PV}(?{S}) <Math/\cup/ ?{PV}(?{E})) - ?{PV}(?{D})/
              <TR>
                <TD/<<?{E1} = ?{E2}>>/
                <TD/?{PV}(?{E1}) <Math/\cup/ ?{PV}(?{E2})/
              <TR>
                <TD/<<[?{E1} &ellipsis; ?{En}]>>/
                <TD/?{PV}(?{E1}) <Math/\cup/ &ellipsis;
                  <Math/\cup/ ?{PV}(?{En})/
              <TR>
                <TD/<<?{E1}|?{E2}>>/
                <TD/?{PV}(?{E1}) <Math/\cup/ ?{PV}(?{E2})/
              <TR>
                <TD/<<?{E1}#&ellipsis;#?{En}>>/
                <TD/?{PV}(?{E1}) <Math/\cup/ &ellipsis;
                  <Math/\cup/ ?{PV}(?{En})/
              <TR>
                <TD/<<?{l}(>>[ ?{f1}<<:>> ]<< ?{E1} &ellipsis; >>[ ?{fn}<<:>>
                  ]<< ?{En} >>[ <<...>> ]<<)>>/
                <TD/?{PV}(?{E1}) <Math/\cup/ &ellipsis;
                  <Math/\cup/ ?{PV}(?{En})/
              <TR>
                <TD/otherwise/
                <TD/<Math/\emptyset//
            </Table>
            <Rewrite>?={statement}
              <Rewrite.From/<<local ?{D} in ?{S} end>>/
              <Rewrite.To/<<local ?{x1} &ellipsis; ?{xn} in ?{D'} ?{S} end>>/
              <Rewrite.Condition/if ?{D} is not a sequence of distinct
                variables and where {?{x1}, &ellipsis;, ?{xn}} = ?{PV}(?{D})
                and ?{D'} is ?{D} with singleton variables and escapes in
                pattern position removed./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = local ?{D} in >>[ ?{S} ]<< ?{E} end>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{x}
   local ?{D} in >>[ ?{S} ]<< ?_{X} = ?{E} end
end>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Grouping/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/<<(?{S})>>/
              <Rewrite.To/?{S}/
            </Rewrite>
            <Rewrite>?={expression}
              <Rewrite.From/<<(?{E})>>/
              <Rewrite.To/?{E}/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Procedure Definitions/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From
/<<proc &ellipsis; {?{E} ?{P1} &ellipsis; ?{Pn}}
   ?{SE}
end>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   proc &ellipsis; {?_{X} ?{P1} &ellipsis; ?{Pn}}
      ?{SE}
   end
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<fun &ellipsis; lazy &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pn}}
   ?{E2}
end>>/
              <Rewrite.To
/<<fun &ellipsis; {?{E1} ?_{X1} &ellipsis; ?_{X}?{n}}
   {`Value.byNeed`
    fun {$}
       case ?_{X1}#&ellipsis;#?_{X}?{n} of ?{P1}#&ellipsis;#?{Pn} then ?{E2}
       end
    end}
end>>/
              <Rewrite.Condition/where all occurrences of <<lazy>> are
                removed from the procedure flags./
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<fun &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pn}}
   ?{E2}
end>>/
              <Rewrite.To
/<<proc &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pn} $}
   ?{E2}
end>>/
              <Rewrite.Condition/if no&nbsp;<<$>> occurs in
                ?{P1} &ellipsis; ?{Pn} and no <<lazy>> occurs
                in the procedure flags./
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<proc &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pk} &ellipsis; ?{Pn}}
   ?{E2}
end>>/
              <Rewrite.To
/<<proc &ellipsis; {?{E1} ?{P1} &ellipsis; ?{Pk'} &ellipsis; ?{Pn}}
   ?_{X} = ?{E2}
end>>/
              <Rewrite.Condition/if <<$>> occurs in&nbsp;?{Pk} and no
                other&nbsp;<<$>> occurs in ?{P1} &ellipsis; ?{Pn} and no
                <<lazy>> occurs in the procedure flags.  ?{Pk'}&nbsp;is
                the result of replacing the&nbsp;<<$>> in&nbsp;?{Pk}
                by&nbsp;?_{X}./
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<proc &ellipsis; {?{E} ?{P1} &ellipsis; ?{Pn}}
   ?{S}
end>>/
              <Rewrite.To
/<<proc &ellipsis; {?{E} ?_{X1} &ellipsis; ?_{X}?{n}}
   case ?_{X1}#&ellipsis;#?_{X}?{n} of ?{P1}#&ellipsis;#?{Pn} then ?{S}
   end
end>>/
              <Rewrite.Condition/if ?{P1} &ellipsis; ?{Pn} are not distinct
                variables and no <<$>> occurs in ?{P1} &ellipsis; ?{Pn} and
                no <<lazy>> occurs in the procedure flags./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From
/<<?{x} = proc &ellipsis; {$ &ellipsis;} ?{SE} end>>/
              <Rewrite.To/<<proc &ellipsis; {?{x} &ellipsis;} ?{SE} end>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Applications/
          <P>
            Actual arguments are evaluated from left to right and after
            the designator expression.
            <Rewrite>?={statement}
              <Rewrite.From/<<{?{E1} &ellipsis; ?{Ek} &ellipsis; ?{En}}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{Ek}
   {?{E1} &ellipsis; ?_{X} &ellipsis; ?{En}}
end>>/
              <Rewrite.Condition/if ?{Ek} is no variable and all ?{Ei} with
                ?{i} &lt; ?{k} are variables./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = {?{E} ?{E1} &ellipsis; ?{En}}>>/
              <Rewrite.To/<<{?{E} ?{E1} &ellipsis; ?{En} ?{x}}>>/
              <Rewrite.Condition/if no <<$>> occurs in ?{E1} &ellipsis; ?{En}
                in pattern position./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From
/<<?{x} = {?{E} ?{E1} &ellipsis; ?{Ek} &ellipsis; ?{En}}>>/
              <Rewrite.To/<<{?{E} ?{E1} &ellipsis; ?{Ek'} &ellipsis; ?{En}}>>/
              <Rewrite.Condition/if <<$>> occurs in&nbsp;?{Ek} in
                pattern position and no other&nbsp;<<$>> occurs in
                ?{E1} &ellipsis; ?{En} in pattern position.
                ?{Ek'} is the result of replacing the&nbsp;<<$>>
                in pattern position in&nbsp;?{Ek} by&nbsp;?{x}./
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Boolean and Pattern-Matching Conditionals/
          <P>
            <Rewrite>?={else statement} ?={else expression}
              <Rewrite.From/<<elseif &ellipsis;>>/
              <Rewrite.To/<<else if &ellipsis; end>>/
            </Rewrite>
            <Rewrite>?={else statement} ?={else expression}
              <Rewrite.From/<<elsecase &ellipsis;>>/
              <Rewrite.To/<<else case &ellipsis; end>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From
/<<if ?{E} then ?{S}
end>>/
              <Rewrite.To
/<<if ?{E} then ?{S}
else skip
end>>/
            </Rewrite>
            <Rewrite>?={expression}
              <Rewrite.From
/<<if ?{E1} then ?{E1}
end>>/
              <Rewrite.To
/<<if ?{E1} then ?{E2}
else
   raise error(kernel(noElse &ellipsis;) &ellipsis;) end
end>>/
              <Rewrite.Condition/where the omitted parts of the exception
                are implementation-dependent./
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<if ?{E} then ?{SE1}
else ?{SE2}
end>>/
              <Rewrite.To
/<<case ?{E} of true then ?{SE1}
[] false then ?{SE2}
else
   raise error(kernel(boolCaseType &ellipsis;) &ellipsis;) end
end>>/
              <Rewrite.Condition/where the omitted parts of the exception
                are implementation-dependent./
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From/<<case ?{E} of &ellipsis; end>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   case ?_{X} of &ellipsis; end
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<case ?{E} of ?{C1} [] &ellipsis; [] ?{Cn}
end>>/
              <Rewrite.To
/<<case ?{E} of ?{C1} [] &ellipsis; [] ?{Cn}
else
   raise error(kernel(noElse &ellipsis;) &ellipsis;) end
end>>/
              <Rewrite.Condition/where the omitted parts of the exception
                are implementation-dependent./
            </Rewrite>
            <Note><!--**-->Missing: expansion of <<case>>
              statement&slash;expression to <<cond>></Note>
        <SubSection class=unnumbered>
          <Title/Locks/
          <P>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From/<<lock ?{E} then ?{SE} end>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   lock ?_{X} then ?{SE} end
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = lock ?{E1} then ?{E2} end>>/
              <Rewrite.To/<<lock ?{E1} then ?{x} = ?{E2} end>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Threads/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = thread ?{E} end>>/
              <Rewrite.To/<<thread ?{x} = ?{E} end>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Exception Handling/
          <P>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<try ?{SE1}
catch ?{C1} [] &ellipsis; [] ?{Cn}
<Span//>>[ <<finally ?{S}>> ]<Code><Span//
end>>/
              <Rewrite.To
/<<try ?{SE1}
catch ?_{X} then
   case ?_{X} of ?{C1} [] &ellipsis; [] ?{Cn}
   else
      raise ?_{X} end
   end
<Span//>>[ <<finally ?{S}>> ]<Code><Span//
end>>/
              <Rewrite.Condition/if <<?{C1} [] &ellipsis; [] ?{Cn}>>
                does not have the form <<?{x} then ?{SE2}>>./
            </Rewrite>
          <P>
            In the following rule, the intermediate variable&nbsp;?_{X}
            ensures that ?{x} is only bound iff evaluation of ?{E} does
            not raise an exception.
            <Rewrite>?={statement}
              <Rewrite.From
/<<?{x} = try ?{E}
    <Span//>>[ <<catch ?{y} then ?{E}>> ]<Code><Span//
    <Span//>>[ <<finally ?{S}>> ]<Code><Span//
    end>>/
              <Rewrite.To
/<<try ?_{X} in
   ?_{X} = ?{E}
   ?{x} = ?_{X}
<Span//>>[ <<catch ?{y} then ?{x} = ?{E}>> ]<Code><Span//
<Span//>>[ <<finally ?{S}>> ]<Code><Span//
end>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From
/<<try &ellipsis;
finally ?{S}
end>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = try
          try &ellipsis; end
          unit
       catch ?_{Y} then ex(?_{Y})
       end
   ?{S}
   case ?_{X} of ex(?_{Z}) then
      raise ?_{Z} end
   else skip
   end
end>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<try ?{SE} end>>/
              <Rewrite.To/?{SE}/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Exception Raising/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/<<raise ?{E} end>>/
              <Rewrite.To/<<{`Exception.raise` ?{E}}>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = raise ?{E} end>>/
              <Rewrite.To/<<raise ?{E} end>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Equations/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/?{E1} = ?{E2}/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?_{X} = ?{E2}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Operators/
          <P>
            <Rewrite>?={expression}
              <Rewrite.From/<<?{o} ?{E}>>/
              <Rewrite.To/<<{?{x} ?{E}}>>/
              <Rewrite.Condition/where ?{o} <Math/\in/ {<<!!>>, <<~>>}
                and ?{x} = ?{CV}(?{o})./
            </Rewrite>
            <Rewrite>?={expression}
              <Rewrite.From/<<?{E1} ?{o} ?{E2}>>/
              <Rewrite.To/<<{?{x} ?{E1} ?{E2}}>>/
              <Rewrite.Condition>where ?{o} <Math/\in/ {<<.>>, <<^>>,
                <<*>>, <</>>, <<div>>, <<mod>>, <<+>>, <<->>, <<==>>,
                <<\=>>, <<&lt;>>, <<=&lt;>>, <<&gt;>>, <<&gt;=>>} and
                ?{x} = ?{CV}(?{o}).
              </Rewrite.Condition>
            </Rewrite>
            ?{CV}(?{o}) denotes the Core variable to which operation&nbsp;?{o}
            is bound.  The following table summarizes in which module from
            <Ptr.Extern to="ozdoc:base"> each operator is available, &eg;,
            <<+>> is available as <<Number.'+'>>, which means that
            ?{CV}(?{o}) = <<`Number.'+'`>>.
            <Table>
              <TR>
                <TH/Operators/
                <TH/Located in Module/
              <TR>
                <TD/<<!!>> <<.>> <<==>> <<\=>>
                  <<&lt;>> <<=&lt;>> <<&gt;>> <<&gt;=>>/
                <TD/<<Value>>/
              <TR>
                <TD/<<~>> <<*>> <<+>> <<->>/
                <TD/<<Number>>/
              <TR>
                <TD/<<div>> <<mod>>/
                <TD/<<Int>>/
              <TR>
                <TD><</>></TD>
                <TD/<<Float>>/
              <TR>
                <TD/<<^>>/
                <TD/<<Record>>/
            </Table>
            <Rewrite>?={expression}
              <Rewrite.From/<<?{E1} andthen ?{E2}>>/
              <Rewrite.To
/<<if ?{E1} then ?{E2}
else false
end
>>/
            </Rewrite>
            <Rewrite>?={expression}
              <Rewrite.From/<<?{E1} orelse ?{E2}>>/
              <Rewrite.To
/<<if ?{E1} then true
else ?{E2}
end
>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Records/
          <P>
            <Rewrite>?={expression} ?={pattern}
              <Rewrite.From/<<[?{EP1} &ellipsis; ?{EPn}]>>/
              <Rewrite.To/<<?{EP1}|&ellipsis;|?{EPn}|nil>>/
            </Rewrite>
            <Rewrite>?={expression} ?={pattern}
              <Rewrite.From/<<?{EP1}|?{EP2}>>/
              <Rewrite.To/<<'|'(?{EP1} ?{EP2})>>/
            </Rewrite>
            <Rewrite>?={expression} ?={pattern}
              <Rewrite.From/<<?{EP1}#&ellipsis;#?{EPn}>>/
              <Rewrite.To/<<'#'(?{EP1} &ellipsis; ?{EPn})>>/
            </Rewrite>
            <Note><!--**-->Missing: dots, omitted features</Note>
        <SubSection class=unnumbered>
          <Title/Uniform State/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = @?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?{x} = @?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite
            <Rewrite>?={statement}
              <Rewrite.From/<<?{E1} := ?{E2}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?_{X} := ?{E2}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} := ?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?_{x} := ?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{E1} := ?{E2}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?{x} = ?_{X} := ?{E2}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{y} := ?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?{x} = ?{y} := ?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{E1}.?{E2} := ?{E3}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?_{X}.?_{E2} := ?{E3}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x}.?{E2} := ?{E3}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E2}
   ?{x}.?_{X} := ?{E3}
end>>/
              <Rewrite.Condition/if ?{E2} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x}.?{y} := ?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?{x}.?{y} := ?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{E1}.?{E2} := ?{E3}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?{x} = ?_{X}.?_{E2} := ?{E3}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{y}.?{E2} := ?{E3}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E2}
   ?{x} = ?{y}.?_{X} := ?{E3}
end>>/
              <Rewrite.Condition/if ?{E2} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{y}.?{z} := ?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?{x} = ?{y}.?{z} := ?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Wildcard/
          <P>
            <Rewrite>?={expression}
              <Rewrite.From/<<_>>/
              <Rewrite.To/<<local ?_{X} in ?_{X} end>>/
            </Rewrite>
            <Rewrite>?={pattern}
              <Rewrite.From/<<_>>/
              <Rewrite.To/<<?_{X}>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Named Constants/
          <P>
            <Rewrite>?={expression} ?={label} ?={feature}
              <Rewrite.From/<<unit>>/
              <Rewrite.To/<<`Unit.'unit'`>>/
            </Rewrite>
            <Rewrite>?={pattern}
              <Rewrite.From/<<unit>>/
              <Rewrite.To/<<!`Unit.'unit'`>>/
            </Rewrite>
            <Rewrite>?={expression} ?={label} ?={feature}
              <Rewrite.From/<<true>>/
              <Rewrite.To/<<`Bool.'true'`>>/
            </Rewrite>
            <Rewrite>?={pattern}
              <Rewrite.From/<<true>>/
              <Rewrite.To/<<!`Bool.'true'`>>/
            </Rewrite>
            <Rewrite>?={expression} ?={label} ?={feature}
              <Rewrite.From/<<false>>/
              <Rewrite.To/<<`Bool.'false'`>>/
            </Rewrite>
            <Rewrite>?={pattern}
              <Rewrite.From/<<false>>/
              <Rewrite.To/<<!`Bool.'false'`>>/
            </Rewrite>
      <Section id="section.translation.constraints">
        <Title/Constraint Extensions and Combinators/
        <SubSection class=unnumbered>
          <Title/Operators/
          <P>
            <Note><!--**-->Missing: fd compare</Note>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{E1} :: ?{E2}>>/
              <Rewrite.To/<<{`FD.int` ?{E2} ?{E1}}>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{E1} ::: ?{E2}>>/
              <Rewrite.To/<<{`FD.dom` ?{E2} ?{E1}}>>/
            </Rewrite>
            <Rewrite>?={expression}
              <Rewrite.From/<<?{E1} :: ?{E2}>>/
              <Rewrite.To/<<{`FD.reified.int` ?{E2} ?{E1}}>>/
            </Rewrite>
            <Rewrite>?={expression}
              <Rewrite.From/<<?{E1} ::: ?{E2}>>/
              <Rewrite.To/<<{`FD.reified.dom` ?{E2} ?{E1}}>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Failure/
          <P>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From/<<fail>>/
              <Rewrite.To/<<raise failure(&ellipsis;) end>>/
              <Rewrite.Condition/where the omitted parts of the exception
                are implementation-dependent./
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Combinators/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/<<not ?{S} end>>/
              <Rewrite.To/<<{`Combinator.'not'` proc {$} ?{S} end}>>/
            </Rewrite>
            <Rewrite>?={statement} ?={expression}
              <Rewrite.From
/<<cond ?{L1} [] &ellipsis; [] ?{Ln}
end>>/
              <Rewrite.To
/<<cond ?{L1} [] &ellipsis; [] ?{Ln}
else
   raise error(kernel(noElse &ellipsis;) &ellipsis;) end
end>>/
              <Rewrite.Condition/where the omitted parts of the exception
                are implementation-dependent./
            </Rewrite>
            <Rewrite>?={cond statement clause} ?={dis statement clause}
              <Rewrite.From/<<?{D} in ?{S1} >>[ <<then ?{S2}>> ]/
              <Rewrite.To
/<<?{x1} &ellipsis; ?{xn} in ?{D'} ?{S1} >>[ <<then ?{S2}>> ]/
              <Rewrite.Condition/if ?{D} is not a sequence of distinct
                variables and where {?{x1}, &ellipsis;, ?{xn}} = ?{PV}(?{D})
                and ?{D'} is ?{D} with singleton variables and escapes
                removed./
            </Rewrite>
            <Rewrite>?={cond expression clause}
              <Rewrite.From/<<?{D} in ?{S} then ?{E}>>/
              <Rewrite.To/<<?{x1} &ellipsis; ?{xn} in ?{D'} ?{S} then ?{E}>>/
              <Rewrite.Condition/if ?{D} is not a sequence of distinct
                variables and where {?{x1}, &ellipsis;, ?{xn}} = ?{PV}(?{D})
                and ?{D'} is ?{D} with singleton variables and escapes
                removed./
            </Rewrite>
            <Note><!--**-->Missing: translation of
              <<cond>>&slash;<<or>>&slash;<<dis>>&slash;<<choice>>
              expression into statement</Note>
            The following rewrite rules make use of an auxiliary
            function ?{Proc}, defined as follows:
            <Table>
              <TR>
                <TH/?{L}/
                <TH/?{Proc}(?{L})/
              <TR>
                <TD/<<?{S1} in ?{S2}>>/
                <TD/<<proc {$} ?{S1} in ?{S2} end>>/
              <TR>
                <TD/<<?{S1} in ?{S2} then ?{S3}>>/
                <TD/<<fun {$} ?{S1} in ?{S2} proc {$} ?{S3} end end>>/
            </Table>
            <Rewrite>?={statement}
              <Rewrite.From/<<cond ?{L1} [] &ellipsis; [] ?{Ln}
else ?{S}
end>>/
              <Rewrite.To/<<{`Combinator.'cond'` '#'(>>?{Proc}(?{L1})<< &ellipsis; >>?{Proc}(?{Ln})<<)
 proc {$} ?{S} end}>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<or ?{L1} [] &ellipsis; [] ?{Ln}
end>>/
              <Rewrite.To/<<{`Combinator.'or'` '#'(>>?{Proc}(?{L1})<< &ellipsis; >>?{Proc}(?{Ln})<<)>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<dis ?{L1} [] &ellipsis; [] ?{Ln}
end>>/
              <Rewrite.To/<<{`Combinator.'dis'` '#'(>>?{Proc}(?{L1})<< &ellipsis; >>?{Proc}(?{Ln})<<)>>/
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<choice ?{S1} [] &ellipsis; [] ?{Sn}>>/
              <Rewrite.To
/<<case {`Space.choose` ?{n}} of 1 then ?{S1}
[] &ellipsis;
[] ?{n} then ?{Sn}
end>>/
            </Rewrite>
      <Section id="section.translation.classes">
        <Title/Class Extensions/
        <SubSection class=unnumbered>
          <Title/Classes/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = class >>[<< $ >>]<< &ellipsis; end>>/
              <Rewrite.To/<<class ?{x} &ellipsis; end>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Method Names/
          <P>
            <Rewrite>?={method head} ?={method head label}
              <Rewrite.From/<<unit>>/
              <Rewrite.To/<<!`Unit.'unit'`>>/
            </Rewrite>
            <Rewrite>?={method head} ?={method head label}
              <Rewrite.From/<<true>>/
              <Rewrite.To/<<!`Bool.'true'`>>/
            </Rewrite>
            <Rewrite>?={method head} ?={method head label}
              <Rewrite.From/<<false>>/
              <Rewrite.To/<<!`Bool.'false'`>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Locks/
          <P>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = lock ?{E} end>>/
              <Rewrite.To/<<lock ?{x} = ?{E} end>>/
            </Rewrite>
        <SubSection class=unnumbered>
          <Title/Operators/
          <P>
    <Rewrite>?={statement}
              <Rewrite.From/<<?{E1} <- ?{E2}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?_{X} <- ?{E2}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} <- ?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?_{x} <- ?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{E1} <- ?{E2}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?{x} = ?_{X} <- ?{E2}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{y} <- ?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?{x} = ?{y} <- ?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x} = ?{E1}, ?{E2}>>/
              <Rewrite.To/<<?{E1}, ?{E2'}>>/
              <Rewrite.Condition/if exactly one <<$>> occurs in&nbsp;?{E2}
                in pattern position.  ?{E2'} is the result of replacing
                this&nbsp;<<$>> in&nbsp;?{E2} by&nbsp;?{x}./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{E1}, ?{E2}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E1}
   ?_{X}, ?{E2}
end>>/
              <Rewrite.Condition/if ?{E1} is no variable./
            </Rewrite>
            <Rewrite>?={statement}
              <Rewrite.From/<<?{x}, ?{E}>>/
              <Rewrite.To
/<<local ?_{X} in
   ?_{X} = ?{E}
   ?_{x}, ?_{X}
end>>/
              <Rewrite.Condition/if ?{E} is no variable./
            </Rewrite>
      <Section id="section.translation.functors">
        <Title/Functor Extensions/
  <Back>
    <Bib.Extern id="ISO_8859_1" to="notation.bib" key="ISO_8859_1">
</Book>
