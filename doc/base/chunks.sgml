<!--
  Translated to SGML by:
     Daniel Simon, dansim@ps.uni-sb.de
     Leif Kornstaedt, kornstae@ps.uni-sb.de
-->

<Chapter id="chapter.chunks">
  <Title/Chunks/
  <Section id="section.chunks.general">
    <Title/Chunks in General/
    <P>
      The module <Span class=index/<<Chunk>>/ contains procedures operating
      on chunks.
      <List>
	<Entry><Span class=index/<<.>>/
	  <Index/<<Value>><And><<'.'>>/
	<Synopsis>
	  <<{Value.'.' ?+{RC} ?+{LI} ?_{X}}>>
	<Item>
	  returns the field&nbsp;?_{X} of&nbsp;?_{RC} at feature&nbsp;?_{LI}.

	<Entry><Span class=index/<<HasFeature>>/
	  <Index/<<Value>><And><<hasFeature>>/
	<Synopsis>
	  <<{Value.hasFeature ?+{RC} ?+{LI} ??{B}}>>
	<Item>
	  tests whether ?_{RC} has feature&nbsp;?_{LI}.

	<Entry><Span class=index/<<CondSelect>>/
	  <Index/<<Value>><And><<condSelect>>/
	<Synopsis>
	  <<{Value.condSelect ?+{RC} ?+{LI} ?_{X} ?_{Y}}>>
	<Item>
	  returns the field&nbsp;?_{Y} of&nbsp;?_{RC} at&nbsp;?_{LI}, if
	  ?_{RC} has feature&nbsp;?_{LI}.  Otherwise, returns&nbsp;?_{X}.

	<Entry><Span class=index/<<IsChunk>>/
	  <Index class=tails/<<Chunk>><And><<is>>/
	<Synopsis>
	  <<{Chunk.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a chunk.

	<Entry><Span class=index/<<NewChunk>>/
	  <Index class=tails/<<Chunk>><And><<new>>/
	<Synopsis>
	  <<{Chunk.new ?+{R} ??{C}}>>
	<Item>
	  returns a new chunk with the same features and fields as&nbsp;?_{R}.
      </List>

  <Section id="section.chunks.arrays">
    <Title/Arrays/
    <P>
      The module <Span class=index/<<Array>>/ contains procedures operating
      on arrays.  Whenever an array access is indexed with an illegal key, an
      error exception is raised.
      <List>
	<Entry><Span class=index/<<IsArray>>/
	  <Index class=tails/<<Array>><And><<is>>/
	<Synopsis>
	  <<{Array.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is an array.

	<Entry><Span class=index/<<NewArray>>/
	  <Index class=tails/<<Array>><And><<new>>/
	<Synopsis>
	  <<{Array.new ?+{LowI} ?+{HighI} ?_{InitX} ??{Array}}>>
	<Item>
	  returns a new array with key range from ?_{LowI} to ?_{HighI}
	  including both.  All items are initialized to ?_{InitX}.

	<Entry><Span class=index/<<Put>>/
	  <Index/<<Array>><And><<put>>/
	<Synopsis>
	  <<{Array.put ?+{Array} ?+{I} ?_{X}}>>
	<Item>
	  sets the item of ?_{Array} under key&nbsp;?_{I} to&nbsp;?_{X}.

	<Entry><Span class=index/<<Get>>/
	  <Index/<<Array>><And><<get>>/
	<Synopsis>
	  <<{Array.get ?+{Array} ?+{I} ?_{X}}>>
	<Item>
	  returns the item of ?_{Array} under key&nbsp;?_{I}.

	<Entry><<low>>
	  <Index class=tails/<<Array>><And><<low>>/
	<Synopsis>
	  <<{Array.low ?+{Array} ??{LowI}}>>
	<Item>
	  returns the lower bound of the key range of ?_{Array}.

	<Entry><<high>>
	  <Index class=tails/<<Array>><And><<high>>/
	<Synopsis>
	  <<{Array.high ?+{Array} ??{HighI}}>>
	<Item>
	  returns the upper bound of the key range of ?_{Array}.

	<Entry><<clone>>
	  <Index class=tails/<<Array>><And><<clone>>/
	<Synopsis>
	  <<{Array.clone ?+{A1} ??{A2}}>>
	<Item>
	  returns a new array with the same bounds and contents as&nbsp;?_{A1}.

	<Entry><<toRecord>>
	  <Index class=tails/<<Array>><And><<toRecord>>/
	<Synopsis>
	  <<{Array.toRecord ?+{L} ?+{A} ??{R}}>>
	<Item>
	  returns a record with label&nbsp;L that contains as features the
	  integers between <<{Array.low ?_{A}}>> and <<{Array.high ?_{A}}>>
	  and with the corresponding fields.
      </List>

  <Section id="section.chunks.dictionaries">
    <Title/Dictionaries/
    <P>
      The module <Span class=index/<<Dictionary>>/ contains procedures
      operating on dictionaries.  If a dictionary contains an item under
      some key&nbsp;?_{LI}, we say ?_{LI} is a <Def/valid key/.  Whenever
      a dictionary access is indexed with an invalid key, a type error is
      raised.
      <List>
	<Entry><Span class=index/<<IsDictionary>>/
	  <Index class=tails/<<Dictionary>><And><<is>>/
	<Synopsis>
	  <<{Dictionary.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a dictionary.

	<Entry><Span class=index/<<NewDictionary>>/
	  <Index class=tails/<<Dictionary>><And><<new>>/
	<Synopsis>
	  <<{Dictionary.new ??{Dictionary}}>>
	<Item>
	  returns a new empty dictionary.

	<Entry><<put>>
	  <Index class=tails/<<Dictionary>><And><<put>>/
	<Synopsis>
	  <<{Dictionary.put ?+{Dictionary} ?+{LI} ?_{X}}>>
	<Item>
	  sets the item in ?_{Dictionary} under key&nbsp;?_{LI} to&nbsp;?_{X}.

	<Entry><<get>>
	  <Index class=tails/<<Dictionary>><And><<get>>/
	<Synopsis>
	  <<{Dictionary.get ?+{Dictionary} ?+{LI} ?_{X}}>>
	<Item>
	  returns the item&nbsp;?_{X} of ?_{Dictionary} under key&nbsp;?_{LI}.

	<Entry><<condGet>>
	  <Index class=tails/<<Dictionary>><And><<condGet>>/
	<Synopsis>
	  <<{Dictionary.condGet ?+{Dictionary} ?+{LI} ?_{X} ?_{Y}}>>
	<Item>
	  returns the item&nbsp;?_{Y} of ?_{Dictionary} under key&nbsp;?_{LI},
	  if ?_{LI} is a valid key of ?_{Dictionary}.  Otherwise,
	  returns&nbsp;?_{X}.

	<Entry><<keys>>
	  <Index class=tails/<<Dictionary>><And><<keys>>/
	<Synopsis>
	  <<{Dictionary.keys ?+{Dictionary} ??{LIs}}>>
	<Item>
	  returns a list of all currently valid keys of ?_{Dictionary}.

	<Entry><<entries>>
	  <Index class=tails/<<Dictionary>><And><<entries>>/
	<Synopsis>
	  <<{Dictionary.entries ?+{Dictionary} ??{Ts}}>>
	<Item>
	  returns the list of current entries of ?_{Dictionary}.  An entry is a
	  pair <<?_{LI}#?_{X}>>, where ?_{LI} is a valid key of ?_{Dictionary}
	  and ?_{X} the corresponding item.

	<Entry><<items>>
	  <Index class=tails/<<Dictionary>><And><<items>>/
	<Synopsis>
	  <<{Dictionary.items ?+{Dictionary} ??{Xs}}>>
	<Item>
	  returns the list of all items currently in ?_{Dictionary}.

	<Entry><<remove>>
	  <Index class=tails/<<Dictionary>><And><<remove>>/
	<Synopsis>
	  <<{Dictionary.remove ?+{Dictionary} ?+{LI}}>>
	<Item>
	  removes the item under key&nbsp;?_{LI} from ?_{Dictionary} if
	  ?_{LI} is a valid key.  Otherwise, does nothing.

	<Entry><<removeAll>>
	  <Index class=tails/<<Dictionary>><And><<removeAll>>/
	<Synopsis>
	  <<{Dictionary.removeAll ?+{Dictionary}}>>
	<Item>
	  removes all entries currently in ?_{Dictionary}.

	<Entry><<member>>
	  <Index class=tails/<<Dictionary>><And><<member>>/
	<Synopsis>
	  <<{Dictionary.member ?+{Dictionary} ?+{LI} ??{B}}>>
	<Item>
	  tests whether ?_{LI} is a valid key of ?_{Dictionary}.

	<Entry><<clone>>
	  <Index class=tails/<<Dictionary>><And><<clone>>/
	<Synopsis>
	  <<{Dictionary.clone ?+{Dictionary1} ??{Dictionary2}}>>
	<Item>
	  returns a new dictionary ?_{Dictionary2} containing the currently
	  valid keys and corresponding items of ?_{Dictionary1}.

	<Entry><<toRecord>>
	  <Index class=tails/<<Dictionary>><And><<toRecord>>/
	<Synopsis>
	  <<{Dictionary.toRecord ?+{L} ?+{Dictionary} ??{R}}>>
	<Item>
	  returns a record&nbsp;?_{R} with label&nbsp;?_{L} whose features
	  and their fields correspond to the keys and their entries of
	  ?_{Dictionary}.
      </List>

  <Section id="section.chunks.bitarrays">
    <Title/Bit Arrays/
    <P>
      The module <Span class=index/<<BitArray>>/ contains procedures operating
      on arrays of bits (&ie;, units of information each being either <Def/set/
      or <Def/reset/).
<list>
	<entry/<span class=index/<code/IsBitArray//
<index class=tails/<code/BitArray/<and><code/is///
	<synopsis/<code/{BitArray.is ?+{X} ??{B}}//
	<item/tests whether ?_{X} is a bit array./

	<entry/<code/new/
<index class=tails/<code/BitArray/<and><code/new///
	<synopsis/<code/{BitArray.new ?+{LowI} ?+{HighI} ??{BitArray}}//
	<item/creates an new ?_{BitArray} with lower bound ?_{LowI}
and upper bound ?_{HighI}, and all bits initially cleared.  This
interface is identical to that of general Oz arrays./

	<entry/<code/set/
<index class=tails/<code/BitArray/<and><code/set///
	<synopsis/<code/{BitArray.set ?+{BitArray} ?+{I}}//
	<item/sets bit&nbsp;?_{I} of ?_{BitArray}./

	<entry/<code/clear/
<index class=tails/<code/BitArray/<and><code/clear///
	<synopsis/<code/{BitArray.clear ?+{BitArray} ?+{I}}//
	<item/clears bit&nbsp;?_{I} of ?_{BitArray}./

	<entry/<code/test/
<index class=tails/<code/BitArray/<and><code/test///
	<synopsis/<code/{BitArray.test ?+{BitArray} ?+{I} ??{B}}//
	<item/tests whether bit&nbsp;?_{I} of ?_{BitArray} is
set./

	<entry/<code/low/
<index class=tails/<code/BitArray/<and><code/low///
	<synopsis/<code/{BitArray.low ?+{BitArray} ??{LowI}}//
	<item/returns the lower bound ?_{LowI} of ?_{BitArray}./

	<entry/<code/high/
<index class=tails/<code/BitArray/<and><code/high///
	<synopsis/<code/{BitArray.high ?+{BitArray} ??{HighI}}//
	<item/returns the upper bound ?_{HighI} of ?_{BitArray}./

	<entry/<code/clone/
<index class=tails/<code/BitArray/<and><code/clone///
	<synopsis/<code/{BitArray.clone ?+{BitArray1} ??{BitArray2}}//
	<item/returns a new bit array that is a copy of its first
argument./

	<entry/<code/disj/
<index class=tails/<code/BitArray/<and><code/disj///
	<synopsis/<code/{BitArray.disj ?+{BitArray1} ?+{BitArray2}}//
	<item/side-effects its first argument with the bitwise <q/or/ of
the two arguments./

	<entry/<code/conj/
<index class=tails/<code/BitArray/<and><code/conj///
	<synopsis/<code/{BitArray.conj ?+{BitArray1} ?+{BitArray2}}//
	<item/side-effects its first argument with the bitwise <q/and/ of
the two arguments./

	<entry/<code/nimpl/
<index class=tails/<code/BitArray/<and><code/nimpl///
	<synopsis/<code/{BitArray.nimpl ?+{BitArray1} ?+{BitArray2}}//
	<item/side-effects its first argument with the bitwise <q/and/ of
the the first argument and the negation of the second argument (&ie;,
negated implication)./

	<entry/<code/disjoint/
<index class=tails/<code/BitArray/<and><code/disjoint///
	<synopsis/<code/{BitArray.disjoint ?+{BitArray1} ?+{BitArray2} ??{B}}//
	<item/tests whether the bit arrays have no set bits in common./

	<entry/<code/card/
<index class=tails/<code/BitArray/<and><code/card///
	<synopsis/<code/{BitArray.card ?+{BitArray} ??{I}}//
	<item/returns the number of set bits./

	<entry/<code/toList/
<index class=tails/<code/BitArray/<and><code/toList///
	<synopsis/<code/{BitArray.toList ?+{BitArray} ??{L}}//
	<item/returns the list of indices for all set bits in ?_{BitArray}./

	<entry/<code/complementToList/
<index class=tails/<code/BitArray/<and><code/complementToList///
	<synopsis/<code/{BitArray.complementToList ?+{BitArray} ??{L}}//
	<item/returns the list of indices for all cleared bits in
?_{BitArray}./

      </list></p>
  </section>

  <Section id="section.chunks.ports">
    <Title/Ports/
    <P>
      The module <Span class=index/<<Port>>/ contains procedures operating on
      ports.
      <List>
	<Entry><Span class=index/<<IsPort>>/
	  <Index class=tails/<<Port>><And><<is>>/
	<Synopsis>
	  <<{Port.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a port.

	<Entry><Span class=index/<<NewPort>>/
	  <Index class=tails/<<Port>><And><<new>>/
	<Synopsis>
	  <<{Port.new ?_{Xs} ??{Port}}>>
	<Item>
	  returns a new port pointing to the stream&nbsp;?_{Xs}.

	<Entry><Span class=index/<<Send>>/
	  <Index/<<Port>><And><<send>>/
	<Synopsis>
	  <<{Port.send ?+{Port} ?_{X}}>>
	<Item>
	  sends ?_{X} to the port ?_{Port}:  The stream pointed to by
	  ?_{Port} is unified with <<?_{X}|_>> (in a newly created thread),
	  and the pointer advances to the stream's new tail.
      </List>

  <Section id="section.chunks.locks">
    <Title/Locks/
    <P>
      The module <Span class=index/<<Lock>>/ contains procedures for locks.
      <List>
	<Entry><Span class=index/<<IsLock>>/
	  <Index class=tails/<<Lock>><And><<is>>/
	<Synopsis>
	  <<{Lock.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a lock.

	<Entry><Span class=index/<<NewLock>>/
	  <Index class=tails/<<Lock>><And><<new>>/
	<Synopsis>
	  <<{Lock.new ??{LockC}}>>
	<Item>
	  creates and returns a new lock.
      </List>

  <Section id="section.chunks.classes">
    <Title/Classes/
    <P>
      The module <Span class=index/<<Class>>/ contains procedures operating
      on classes.
      <List>
	<Entry><Span class=index/<<IsClass>>/
	  <Index class=tails/<<Class>><And><<is>>/
	<Synopsis>
	  <<{Class.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a class.

	<Entry><Span class=index/<<IsInstanceOf>>/
	  <Index/<<Class>><And><<isInstanceOf>>/
	<Synopsis>
	  <<{Class.isInstanceOf ?+{O} ?+{K} ??{B}}>>
	<Item>
	  The object&nbsp;?_{O} is an instance of the class&nbsp;?_{K},
	  &ie;, ?_{K}&nbsp;is above the class of&nbsp;?_{O} in the inheritance
	  hierarchy.

	<Entry><<get>>
	  <Index class=tails/<<Class>><And><<get>>/
	<Synopsis>
	  <<{Class.get ?+{O} ??{K}}>>
	<Item>
	  binds ?_{K} to the class of&nbsp;?_{O}.

	<Entry><<methodNames>>
	  <Index class=tails/<<Class>><And><<methodNames>>/
	<Synopsis>
	  <<{Class.methodNames ?+{K} ??{Ls}}>>
	<Item>
	  returns the alphabetically sorted list of public (atomic) method
	  names that the instances of the class&nbsp;?_{K} can serve.
	  <!--** this is not true currently, names are also returned -->

	<!--** attrNames, featNames, propNames, extendFeatures, hasProperty -->

	<Entry><<parents>>
	  <Index class=tails/<<Class>><And><<parents>>/
	<Synopsis>
	  <<{Class.parents ?+{K} ??{Ks}}>>
	<Item>
	  binds ?_{Ks} to the list of direct parents of&nbsp;?_{K} in the
	  order of increasing priority.

	<Entry><<getFeature>>
	  <Index class=tails/<<Class>><And><<getFeature>>/
	<Synopsis>
	  <<{Class.getFeature ?+{K} ?+{LI} ??{X}}>>
	<Item>
	  returns the class feature&nbsp;?_{X} of&nbsp;?_{K} at&nbsp;?_{LI}.

	<Entry><<hasFeature>>
	  <Index class=tails/<<Class>><And><<hasFeature>>/
	<Synopsis>
	  <<{Class.hasFeature ?+{K} ?+{LI} ??{B}}>>
	<Item>
	  tests whether ?_{K} has class feature at&nbsp;?_{LI}.
      </List>

  <Section id="section.chunks.objects">
    <Title/Objects/
    <P>
      The module <Span class=index/<<Object>>/ contains procedures operating
      on objects.
    <P>
      The system procedures that define the behaviour of &Oz; objects and
      classes are also given in this section.
      <List>
	<Entry><Span class=index/<<IsObject>>/
	  <Index class=tails/<<Object>><And><<is>>/
	<Synopsis>
	  <<{Object.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is an object.

	<Entry><Span class=index/<<New>>/
	  <Index class=tails/<<Object>><And><<new>>/
	<Synopsis>
	  <<{Object.new ?+{K} ?+{InitMessageR} ??{O}}>>
	<Item>
	  Creates a new object from class&nbsp;?_{K} with initial message
	  ?_{InitMessageR}.

	<!--** ',', '@', '<-', exchange, send, 'class', meta -->
      </List>
    <SubSection class=unnumbered>
      <Title/The <<BaseObject>> Class/
      <P>
	<Index class=tails/<<Object>><And><<base>>/
	The class <Span class=index/<<BaseObject>>/ defines the following
	method.
	<List>
	  <Entry><<noop>>
	    <Index/<<Object>><And><<base>><And><<noop>>/
	  <Synopsis>
	    <<noop()>>
	  <Item>
	    does nothing.  It is defined as <<meth noop() skip end>>.
	</List>
    <SubSection class=unnumbered>
      <Title/Classes for Master&slash;Slave Behaviour/
      <P>
	<Index class=tails/<<Object>><And><<master>>/
	An instance ?_{MasterO} of class <<Object.master>> becomes
	a <Def/master/ of an <<Object.slave>> object when the latter
	receives the message <<becomeSlave(?_{MasterO})>>.
      <Para class=apropos><Title/Methods for Masters/
	<List>
	  <Entry><<init>>
	    <Index/<<Object>><And><<master>><And><<init>>/
	  <Synopsis>
	    <<init()>>
	  <Item>
	    initialization; mandatory for internal reasons.

	  <Entry><<getSlaves>>
	    <Index/<<Object>><And><<master>><And><<getSlaves>>/
	  <Synopsis>
	    <<getSlaves(??{SlaveOs})>>
	  <Item>
	    binds ?_{SlavesOs} to the list of current slaves.
	</List>
      <P>
	<Index class=tails/<<Object>><And><<slave>>/
	An instance of <<Object.slave>> becomes a <Def/slave/ of an
	<<Object.master>> object ?_{MasterO} when it receives the message
	<<becomeSlave(?_{MasterO})>>.
      <Para class=apropos><Title/Methods for Slaves/
	<List>
	  <Entry><<becomeSlave>>
	    <Index/<<Object>><And><<slave>><And><<becomeSlave>>/
	  <Synopsis>
	    <<becomeSlave(?+{MasterO})>>
	  <Item>
	    makes <<self>> become a slave of ?_{MasterO}.  <<self>> must
	    not yet be a slave of any object, else the error exception
	    <<object(slaveNotFree)>> is raised.

	  <Entry><<isFree>>
	    <Index/<<Object>><And><<slave>><And><<isFree>>/
	  <Synopsis>
	    <<isFree(??{B})>>
	  <Item>
	    tests whether <<self>> is not the slave of any object.

	  <Entry><<free>>
	    <Index/<<Object>><And><<slave>><And><<free>>/
	  <Synopsis>
	    <<free()>>
	  <Item>
	    frees <<self>>.  <<self>> must be the slave of some object,
	    else the error exception <<object(slaveAlreadyFree)>> is
	    raised.
	</List>

  <Section id="section.chunks.functors">
    <Title/Functors/
    <P>
      The module <Span class=index/<<Functor>>/ contains procedures operating
      on functors.
      <List>
	<Entry><<is>>
	  <Index class=tails/<<Functor>><And><<is>>/
	<Synopsis>
	  <<{Functor.is ?+{X} ??{B}}>>
	<Item>
	  tests whether ?_{X} is a functor.

	<Entry><<new>>
	  <Index class=tails/<<Functor>><And><<new>>/
	<Synopsis>
	  <<{Functor.new ?+{T1} ?+{T2} ?+{P} ??{B}}>>
	<Item>
	  returns a new functor with imports as described by&nbsp;?_{T1},
	  exports as described by&nbsp;?_{T2} and body as performed
	  by&nbsp;?_{P}.
	  <!--** be a bit more verbose -->

	<Entry><<getFeatures>>
	  <Index class=tails/<<Functor>><And><<getFeatures>>/
	<Synopsis>
	  <<{Functor.getFeatures ?+{Functor} ??{LIs}}>>
	<Item>
	  returns a list of the features exported by <<?_{Functor}>>.
      </List>
</Chapter>

<!--
Local Variables:
mode: sgml
mode: auto-fill
sgml-default-dtd-file: "chapter.ced"
sgml-auto-activate-dtd: t
adaptive-fill-mode: nil
End:
-->
