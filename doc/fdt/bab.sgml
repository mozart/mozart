<!--
  - Authors:
  -   Christian Schulte <schulte@dfki.de>
  -   Gert Smolka <smolka@dfki.de>
  -   Jörg Würtz
  -
  - Contributors:
  -   Daniel Simon <dansim@ps.uni-sb.de>
  -   Andy Walter <anwalt@ps.uni-sb.de>
  -   
  - Copyright:
  -   Christian Schulte, 1998
  -   Gert Smolka, 1998
  -   Jörg Würtz, 1997
  -
  - Last change:
  -   $Date$ by $Author$
  -   $Revision$
  -
  - This file is part of Mozart, an implementation
  - of Oz 3
  -    http://mozart.ps.uni-sb.de
  -
  - See the file "LICENSE" or
  -    http://mozart.ps.uni-sb.de/LICENSE.html
  - for information on usage and redistribution
  - of this file, and for a DISCLAIMER OF ALL
  - WARRANTIES.
  -
  -->

<chapter id=chapter.branchandbound>
<title/Branch and Bound/<p>

In this chapter we focus on computing an optimal solution according
to a given cost function.  While we have searched for optimal solutions
already in <Ptr to="sec.reified.photo"> and <Ptr to="sec.reified.bin">, we
have used a rather ad-hoc strategy there. This strategy lacks generality and 
does not provide either for a proof of optimality.
<p>
In this section we introduce a general schema to compute an optimal
solution according to an arbitrary cost function and show how it is
available in Oz. This schema is called
<para><title/branch and bound/<def/branch and bound/ and is available 
by  procedures like <<ExploreBest>> (see <Ptr to="ozdoc.modules"> for more
search engines). A typical application of <<ExploreBest>> for a script <<Script>>
looks like
<<<
{ExploreBest Script Order}
>>>
The branch and bound schema works as follows. When a solution of
<<Script>> is found, all the remaining alternatives in the search tree
are constrained to be <def/better/ with respect to an order available
through the procedure <<Order>>.  Usually <<Order>> applies a cost
function to its arguments and creates a propagator imposing
the ordering. The first argument of <<Order>> is the previous solution,
and the second argument is an alternative solution we are searching for.
</chapter>

